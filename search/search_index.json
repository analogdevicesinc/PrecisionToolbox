{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p> <p></p> <p>ADI maintains a set of tools to interface with ADI precision converters within MATLAB and Simulink. These are combined into a single toolbox. The list of supported parts is provided below.</p> <p>The following have device-specific implementations in MATLAB and Simulink. If a device has an IIO driver, MATLAB support is possible, but a device-specific MATLAB or Simulink interface may not exist yet.</p> Evaluation Card FPGA Board Streaming Support Targeting Variants and Minimum Supported Release AD7380 Zedboard Yes No ADI (2021b) AD7768 Zedboard Yes No ADI (2021b) AD7768-1 Zedboard Yes No ADI (2021b) AD4030-24 Zedboard Yes No ADI (2021b) AD4630-16 Zedboard Yes No ADI (2021b) AD4630-24 Zedboard Yes No ADI (2021b) AD4858 Zedboard Yes No ADI (2021b) AD2S1210 Zedboard Yes No ADI (2021b) AD4000 Zedboard Yes No ADI (2021b) AD4001 Zedboard Yes No ADI (2021b) AD4002 Zedboard Yes No ADI (2021b) AD4003 Zedboard Yes No ADI (2021b) AD4004 Zedboard Yes No ADI (2021b) AD4005 Zedboard Yes No ADI (2021b) AD4006 Zedboard Yes No ADI (2021b) AD4007 Zedboard Yes No ADI (2021b) AD4008 Zedboard Yes No ADI (2021b) AD4010 Zedboard Yes No ADI (2021b) AD4011 Zedboard Yes No ADI (2021b) AD4020 Zedboard Yes No ADI (2021b) AD4021 Zedboard Yes No ADI (2021b) AD4022 Zedboard Yes No ADI (2021b) AD7124-4 Zedboard Yes No ADI (2021b) AD7124-8 Zedboard Yes No ADI (2021b)"},{"location":"examples/","title":"Examples","text":"<p>Examples for streaming data are listed within the Toolbox documentation itself. To view run the following with MATLAB:</p> <pre><code>doc adi\n</code></pre> <p>They can also be viewed on GitHub:</p> <ul> <li>Streaming examples</li> </ul>"},{"location":"install/","title":"Installation","text":""},{"location":"install/#dependencies","title":"Dependencies","text":"<p>The toolbox has different dependencies based on the features required. The base dependencies for streaming data are listed below. </p>"},{"location":"install/#data-streaming-with-hardware","title":"Data Streaming with Hardware","text":"<p>The base dependencies for the toolbox requires libiio and the libiio MATLAB bindings. There are three options for this install with different required MathWorks Toolboxes:</p> <ul> <li>Communications Toolbox Support Package for Xilinx Zynq-Based Radio<ul> <li>Communications Toolbox</li> <li>Signal Processing Toolbox<sup>TM</sup></li> <li>DSP System Toolbox<sup>TM</sup></li> </ul> </li> <li>Communications Toolbox Support Package for Analog Devices ADALM-Pluto Radio<ul> <li>Communications Toolbox</li> <li>Signal Processing Toolbox<sup>TM</sup></li> <li>DSP System Toolbox<sup>TM</sup></li> </ul> </li> <li>libiio MATLAB Binding Standalone Installer (R2021b+)<ul> <li>Signal Processing Toolbox<sup>TM</sup></li> </ul> </li> </ul>"},{"location":"install/#precision-toolbox-install","title":"Precision Toolbox Install","text":"<p>The Precision Toolbox itself can be installed either from:</p> <ul> <li>MATLAB's Add-On Explorer </li> <li>GitHub Releases page.</li> </ul> <p>MATLAB Versions</p> <p>Before installing Precision Toolbox check the Release Page to check for the latest supported version of MATLAB. The latest version is the one which is available in Add-on Explorer, since Add-On Explorer does not currently support hosting multiple versions. If you have an older release of MATLAB, download the MLTBX installer from matching release on the Release Page.</p>"},{"location":"install/#add-on-explorer-walkthrough","title":"Add-On Explorer Walkthrough","text":"<p>To install the toolbox from within MATLAB using the Add-On Explorer:</p> <ul> <li>Launch the Add-Ons Explorer from MATLAB's Home tab</li> <li>Search for 'Precision Toolbox'</li> <li>Select Precision Toolbox from Analog Devices, Inc. from the results:</li> <li>Install the toolbox</li> </ul>"},{"location":"limitations/","title":"Known Limitations, Bugs and Quirks","text":"<p>Some limitations and bugs are known to be present in the support for the ADCs relevant to the Precision Toolbox. They have been summarized below.</p>"},{"location":"limitations/#libiio-backend","title":"Libiio backend","text":"<p>Currently only ethernet/IP backends are supported for all the parts in the toolbox. For AD4030-24, AD4630-16 and AD4630-24 the usb backend can also be used. Serial backends are not supported.  </p>"},{"location":"limitations/#ad7380","title":"AD7380","text":"<p>Trigger setup needs to be done before running any of the toolbox scripts that interact with the AD7380. Refer to the Trigger Management section on the AD738x Linux IIO driver wiki page</p>"},{"location":"limitations/#ad7768","title":"AD7768","text":"<p>The Linux IIO driver for the AD7768 returns data for all the channels whenever a data capture is requested. So, in order to get sensible outputs, ensure that the EnabledChannels array consists of indices for all the channels. </p>"},{"location":"limitations/#ad4030-24-ad4630-16-ad4630-24","title":"AD4030-24. AD4630-16, AD4630-24","text":"<p>The Linux IIO driver for the three parts (there's a common Linux driver that addresses all three parts) returns data for all the channels whenever a data capture is requested. In order to have sensible outputs, ensure that the EnabledChannels array consists of indices for all the channels. </p> <p>Another known issue here has to do with the case where the ADC sends out common mode voltage data along with the differential voltage data. The EnabledChannel property values that consist of more than two indices (even when there are 4 IIO channels), are not 'valid'. Of the possible groupings with two channel indices, the ones that correspond to {differential0, common_voltage0} and {differential1, common_voltage1} are also not 'valid' </p> <p>It is possible to get data (common-mode and differential) for all the ADC channels, by using a 'valid' channel grouping, setting the BufferTypeConversionEnable property to 'false' in the Base class for the AD463x family, and adding custom parsing logic to extract the data for all IIO channels, from the 32-bit raw words you get from the data capture.</p>"},{"location":"models/","title":"Behavioral Models","text":"<p>The toolbox contains behavioral simulation models of different data converters that can be used in MATLAB and Simulink. These are designed to help users understand device limitations and advanced feature sets. As well as to test their algorithms and signal processing against. The currently supported behavioral models are:</p> <ul> <li>AD9081 MxFE Quad, 16-Bit, 12GSPS RFDAC and Quad, 12-Bit, 4GSPS RFADC</li> </ul>"},{"location":"objects/","title":"Hardware Interface APIs","text":"<p>Available hardware streaming interfaces in PCX Toolbox:</p> <ul> <li>adi.AD7380.Rx</li> <li>adi.AD7768.Rx</li> <li>adi.AD7768_1.Rx</li> <li>adi.AD4030.Rx</li> <li>adi.AD4630_16.Rx</li> <li>adi.AD4630_24.Rx</li> <li>adi.AD4858.Rx</li> <li>adi.AD2S1210.Rx</li> <li>adi.AD4000.Rx</li> <li>adi.AD4001.Rx</li> <li>adi.AD4002.Rx</li> <li>adi.AD4003.Rx</li> <li>adi.AD4004.Rx</li> <li>adi.AD4005.Rx</li> <li>adi.AD4006.Rx</li> <li>adi.AD4007.Rx</li> <li>adi.AD4008.Rx</li> <li>adi.AD4010.Rx</li> <li>adi.AD4011.Rx</li> <li>adi.AD4020.Rx</li> <li>adi.AD4021.Rx</li> <li>adi.AD4022.Rx</li> <li>adi.AD5760.Tx</li> <li>adi.AD5780.Tx</li> <li>adi.AD5781.Tx</li> <li>adi.AD5790.Tx</li> <li>adi.AD5791.Tx</li> <li>adi.AD7124_4.Rx</li> <li>adi.AD7124_8.Rx</li> </ul> <p>Click on left table of contents for individual component pages.</p>"},{"location":"streaming/","title":"Receiving and Sending Data","text":"<p>Remote data streaming to and from hardware is made available through system object interfaces, which are unique for each component or platform. The hardware interfacing system objects provide a since class to both configure a given platform and move data back and forth from the device.</p> <p>Command and control of hardware from MATLAB is accomplished by leveraging the IIO drivers built into the target platform's kernel and libiio which provides remote backends to control drivers across different backends. Backends can be Ethernet/IP/USB based. Below is a diagram of the different components in the stack for a setup targeting the evaluation of the AD7380, but the setup will be nearly similar for other ADCs as well. </p> <p></p> <p>Since libiio is cross-platform it can be used from Windows, Linux, or macOS based systems. It is also a lower level library independent of MATLAB, so when moving toward production or untethered systems similar APIs that are used in MATLAB can be used in C,C++,Python, or other languages.</p>"},{"location":"streaming/#connecting-and-configuration","title":"Connecting and Configuration","text":"<p>Connecting to hardware is done by setting the uri property of the system object interface. The uri for libiio always has the convention \"&lt; backend &gt;:&lt; address &gt;\", where backend can be ethernet, ip or usb. address will be specific to the backend. This is documented in the libiio API.</p> <p>Below is a basic example of setting up a generic ADC using an Ethernet/IP backend: <pre><code>rx = adi.ADxxxx.Rx;\nrx.uri = 'ip:analog.local';\ndata = rx();\n</code></pre> With the code above, the hardware is not contacted until the operator or step method is called on line 3. Therefore, any properties that are set or defined before line 3 are not applied or updated on the hardware until after line 3. However, after line 3 has completed the object will become locked and certain configuration changes cannot be applied after this point. These will primarily sample rates and buffer sizes.</p> <p>The state of the object follows the flow of the diagram below triggered by line 3 above.</p> <p>graph LR   Z[Operator Called] --&gt;A;   A[Connect To Board] --&gt; B[Update Properties];   B --&gt; C[Initialize Buffers];   C --&gt; D[Send or Receive Data];   D --&gt; E[Lock Object];  Once the object becomes locked it must be released if the sample rate or buffers need to be modified. This will disconnect from the hardware: <pre><code>rx.release(); % Release object\n</code></pre></p> <p>To provide a complete example we can do more advanced configuration like so to demonstrate property changes: <pre><code>rx = adi.ADxxxx.Rx;\nrx.uri = 'ip:analog.local';\nrx.SamplesPerFrame = 1024;\nrx.SampleRate = 256000;\ndata1 = rx();\n\n% Update tunable property\nrx.SampleRate = 128000;\ndata2 = rx();\n\n% Update non-tunable property\nrx.release();\nrx.SamplesPerFrame = 4096;\ndataLargerBuffer = rx();\n</code></pre></p>"},{"location":"streaming/#receiving-data","title":"Receiving Data","text":"<p>To receive or capture data from a given device first you must instantiate that device's interface class. For a generic ADC, this would be as follows:</p> <pre><code>rx = adi.ADxxxx.Rx;\n</code></pre> <p>Once instantiated you can configure the number of samples to be captured by setting the property SamplesPerFrame.</p> <pre><code>rx.SamplesPerFrame = 1e6;\n</code></pre> <p>SamplesPerFrame is the number of samples per channel which will be captured. If your device produces complex data (I and Q) this is the number of complex samples. There will be a limit to the maximum samples which can be collected. By default this is set to 2^20, but it may be possible to make it larger depending on hardware. Once the operator methods are used for a give instantiation, the object will become locked and the SamplesPerFrame property cannot be changed. This is known as a non-tunable property.</p> <p>To actually collect the samples or perform the capture, the operator of the system object should be used or the step method as so:</p> <pre><code>data = rx(); % Operator method\ndata = rx.step(); % Step method\n</code></pre> <p>Both method calls are equivalent, and the produced matrix data will be of size [SamplesPerFrame x length(EnabledChannels)]. EnabledChannels determines the channels which data will be collected from. EnabledChannels is a [1xN] vector with indexes starting at 1 of the desired channels. </p>"},{"location":"streaming/#continuous-data-acquisition","title":"Continuous Data Acquisition","text":"<p>If you are capturing multiple frames or buffers of data, then there might arise situations where discontinuities appear in the samples, when plotted. </p> <p>Some detail and tips are discussed in this wiki page on IIO System Considerations, Tips and Tricks</p> <p>The IIO buffer size is governed by the SamplesPerFrame property of the System Object classes. The kernelBuffersCount is also a property defined for the classes, and can be modified. </p>"},{"location":"support/","title":"Support","text":"<p>Support is provided online through the EngineerZone forums. If you have questions related to the hardware itself outside of this BSP, contact your local FAE or ask on the forums.</p> <p>Question regarding specific aspect of the BSP should be asked in the following places:</p> <ul> <li>Software Interface Tools for questions on the BSP itself</li> <li>Linux Software Drivers for libiio and iio driver questions</li> </ul>"},{"location":"targeting/","title":"HDL Targeting with HDL-Coder","text":"<p>High-Speed Converter Toolbox supports the IP Core generation flow from MathWorks which allows for automated integration of DSP into HDL reference designs from Analog Devices. This workflow will take Simulink subsystems, run HDL-Coder to generate source Verilog, and then integrate that into a larger reference design. The figure below is a simplified block diagram of a SoC (Fabric+ARM) device, where specialized IP are inserted into the receive and transmit datapaths. This is supported on specific FPGA families and high-speed based reference designs. This support is based on the Zynq HDL-Coder and support</p> <p></p>"},{"location":"targeting/#recommended-review","title":"Recommended Review","text":"<ul> <li>Getting started with Zynq</li> </ul>"},{"location":"targeting/#getting-started","title":"Getting Started","text":"<p>To perform targeting will require FPGA vendor tools for the FPGA system. For Xilinx this will be Vivado and the toolbox will require specific versions for each release. For the current release this is Vivado 2019.1. Using other versions are not supported. To build the necessary BOOT.BIN files will require the Xilinx SDK as well.</p> <p>Once you have the installed the necessary 3rd party tools MATLAB needs to be told where they are installed by use of the hdlsetuptoolpath command. For Windows the following MATLAB command can be used:</p> <pre><code>hdlsetuptoolpath('ToolName', 'Xilinx Vivado', 'ToolPath', 'C:\\Xilinx\\Vivado\\2019.1\\bin\\vivado.bat');\n</code></pre> <p>or Linux:</p> <pre><code>hdlsetuptoolpath('ToolName', 'Xilinx Vivado', 'ToolPath', '/opt/Xilinx/Vivado/2019.1/bin/vivado');\n</code></pre> <p>Please change the tool path if it is different on your system.</p>"},{"location":"targeting/#checking-for-supported-designs","title":"Checking For Supported Designs","text":"<p>To verify that the ADI reference designs are available to HDL Workflow Advisor a Simulink model needs to be opened. To do so launch Simulink with the following command:</p> <pre><code>simulink\n</code></pre> <p>After it launches open a \"Blank DUT\" model from the \"HDL Coder\" dropdown of the Simulink Start Page.</p> <p></p> <p>After the model opens, click on the green subsystem to select it. Then open the \"Apps\" tap, open the apps menu and scroll down to HDL-Coder.</p> <p></p> <p>This will open the HDL-Coder menu, from here the Workflow Advisor is selectable. Click on it to launch the advisor.</p> <p></p> <p>Once launch go to Step 1.1 on the left side column. Then on the right side of the window select \"IP Core Generation\" for \"Target workflow\". Then the ADI reference designs should be available in the \"Target platform\" menu as so:</p> <p></p>"},{"location":"_pages/","title":"Index","text":"<p>{% include 'header.tmpl' %}</p> <p> <p></p> <p>ADI maintains a set of tools to interface with ADI precision converters within MATLAB and Simulink. These are combined into a single toolbox. The list of supported parts is provided below.</p> <p>The following have device-specific implementations in MATLAB and Simulink. If a device has an IIO driver, MATLAB support is possible, but a device-specific MATLAB or Simulink interface may not exist yet.</p> Evaluation Card FPGA Board Streaming Support Targeting Variants and Minimum Supported Release AD7380 Zedboard Yes No ADI (2021b) AD7768 Zedboard Yes No ADI (2021b) AD7768-1 Zedboard Yes No ADI (2021b) AD4030-24 Zedboard Yes No ADI (2021b) AD4630-16 Zedboard Yes No ADI (2021b) AD4630-24 Zedboard Yes No ADI (2021b) AD4858 Zedboard Yes No ADI (2021b) AD2S1210 Zedboard Yes No ADI (2021b) AD4000 Zedboard Yes No ADI (2021b) AD4001 Zedboard Yes No ADI (2021b) AD4002 Zedboard Yes No ADI (2021b) AD4003 Zedboard Yes No ADI (2021b) AD4004 Zedboard Yes No ADI (2021b) AD4005 Zedboard Yes No ADI (2021b) AD4006 Zedboard Yes No ADI (2021b) AD4007 Zedboard Yes No ADI (2021b) AD4008 Zedboard Yes No ADI (2021b) AD4010 Zedboard Yes No ADI (2021b) AD4011 Zedboard Yes No ADI (2021b) AD4020 Zedboard Yes No ADI (2021b) AD4021 Zedboard Yes No ADI (2021b) AD4022 Zedboard Yes No ADI (2021b) AD7124-4 Zedboard Yes No ADI (2021b) AD7124-8 Zedboard Yes No ADI (2021b)"},{"location":"_pages/examples/","title":"Examples","text":"<p>{% include 'header.tmpl' %}</p>"},{"location":"_pages/examples/#examples","title":"Examples","text":"<p>Examples for streaming data are listed within the Toolbox documentation itself. To view run the following with MATLAB:</p> <pre><code>doc adi\n</code></pre> <p>They can also be viewed on GitHub:</p> <ul> <li>Streaming examples</li> </ul>"},{"location":"_pages/install/","title":"Install","text":"<p>{% include 'header.tmpl' %}</p>"},{"location":"_pages/install/#installation","title":"Installation","text":""},{"location":"_pages/install/#dependencies","title":"Dependencies","text":"<p>The toolbox has different dependencies based on the features required. The base dependencies for streaming data are listed below. </p>"},{"location":"_pages/install/#data-streaming-with-hardware","title":"Data Streaming with Hardware","text":"<p>The base dependencies for the toolbox requires libiio and the libiio MATLAB bindings. There are three options for this install with different required MathWorks Toolboxes:</p> <ul> <li>Communications Toolbox Support Package for Xilinx Zynq-Based Radio<ul> <li>Communications Toolbox</li> <li>Signal Processing Toolbox<sup>TM</sup></li> <li>DSP System Toolbox<sup>TM</sup></li> </ul> </li> <li>Communications Toolbox Support Package for Analog Devices ADALM-Pluto Radio<ul> <li>Communications Toolbox</li> <li>Signal Processing Toolbox<sup>TM</sup></li> <li>DSP System Toolbox<sup>TM</sup></li> </ul> </li> <li>libiio MATLAB Binding Standalone Installer (R2021b+)<ul> <li>Signal Processing Toolbox<sup>TM</sup></li> </ul> </li> </ul>"},{"location":"_pages/install/#precision-toolbox-install","title":"Precision Toolbox Install","text":"<p>The Precision Toolbox itself can be installed either from:</p> <ul> <li>MATLAB's Add-On Explorer </li> <li>GitHub Releases page.</li> </ul> <p>MATLAB Versions</p> <p>Before installing Precision Toolbox check the Release Page to check for the latest supported version of MATLAB. The latest version is the one which is available in Add-on Explorer, since Add-On Explorer does not currently support hosting multiple versions. If you have an older release of MATLAB, download the MLTBX installer from matching release on the Release Page.</p>"},{"location":"_pages/install/#add-on-explorer-walkthrough","title":"Add-On Explorer Walkthrough","text":"<p>To install the toolbox from within MATLAB using the Add-On Explorer:</p> <ul> <li>Launch the Add-Ons Explorer from MATLAB's Home tab</li> <li>Search for 'Precision Toolbox'</li> <li>Select Precision Toolbox from Analog Devices, Inc. from the results:</li> <li>Install the toolbox</li> </ul>"},{"location":"_pages/limitations/","title":"Limitations","text":"<p>{% include 'header.tmpl' %}</p>"},{"location":"_pages/limitations/#known-limitations-bugs-and-quirks","title":"Known Limitations, Bugs and Quirks","text":"<p>Some limitations and bugs are known to be present in the support for the ADCs relevant to the Precision Toolbox. They have been summarized below.</p>"},{"location":"_pages/limitations/#libiio-backend","title":"Libiio backend","text":"<p>Currently only ethernet/IP backends are supported for all the parts in the toolbox. For AD4030-24, AD4630-16 and AD4630-24 the usb backend can also be used. Serial backends are not supported.  </p>"},{"location":"_pages/limitations/#ad7380","title":"AD7380","text":"<p>Trigger setup needs to be done before running any of the toolbox scripts that interact with the AD7380. Refer to the Trigger Management section on the AD738x Linux IIO driver wiki page</p>"},{"location":"_pages/limitations/#ad7768","title":"AD7768","text":"<p>The Linux IIO driver for the AD7768 returns data for all the channels whenever a data capture is requested. So, in order to get sensible outputs, ensure that the EnabledChannels array consists of indices for all the channels. </p>"},{"location":"_pages/limitations/#ad4030-24-ad4630-16-ad4630-24","title":"AD4030-24. AD4630-16, AD4630-24","text":"<p>The Linux IIO driver for the three parts (there's a common Linux driver that addresses all three parts) returns data for all the channels whenever a data capture is requested. In order to have sensible outputs, ensure that the EnabledChannels array consists of indices for all the channels. </p> <p>Another known issue here has to do with the case where the ADC sends out common mode voltage data along with the differential voltage data. The EnabledChannel property values that consist of more than two indices (even when there are 4 IIO channels), are not 'valid'. Of the possible groupings with two channel indices, the ones that correspond to {differential0, common_voltage0} and {differential1, common_voltage1} are also not 'valid' </p> <p>It is possible to get data (common-mode and differential) for all the ADC channels, by using a 'valid' channel grouping, setting the BufferTypeConversionEnable property to 'false' in the Base class for the AD463x family, and adding custom parsing logic to extract the data for all IIO channels, from the 32-bit raw words you get from the data capture.</p>"},{"location":"_pages/models/","title":"Models","text":"<p>{% include 'header.tmpl' %}</p>"},{"location":"_pages/models/#behavioral-models","title":"Behavioral Models","text":"<p>The toolbox contains behavioral simulation models of different data converters that can be used in MATLAB and Simulink. These are designed to help users understand device limitations and advanced feature sets. As well as to test their algorithms and signal processing against. The currently supported behavioral models are:</p> <ul> <li>AD9081 MxFE Quad, 16-Bit, 12GSPS RFDAC and Quad, 12-Bit, 4GSPS RFADC</li> </ul>"},{"location":"_pages/streaming/","title":"Streaming","text":"<p>{% include 'header.tmpl' %}</p>"},{"location":"_pages/streaming/#receiving-and-sending-data","title":"Receiving and Sending Data","text":"<p>Remote data streaming to and from hardware is made available through system object interfaces, which are unique for each component or platform. The hardware interfacing system objects provide a since class to both configure a given platform and move data back and forth from the device.</p> <p>Command and control of hardware from MATLAB is accomplished by leveraging the IIO drivers built into the target platform's kernel and libiio which provides remote backends to control drivers across different backends. Backends can be Ethernet/IP/USB based. Below is a diagram of the different components in the stack for a setup targeting the evaluation of the AD7380, but the setup will be nearly similar for other ADCs as well. </p> <p></p> <p>Since libiio is cross-platform it can be used from Windows, Linux, or macOS based systems. It is also a lower level library independent of MATLAB, so when moving toward production or untethered systems similar APIs that are used in MATLAB can be used in C,C++,Python, or other languages.</p>"},{"location":"_pages/streaming/#connecting-and-configuration","title":"Connecting and Configuration","text":"<p>Connecting to hardware is done by setting the uri property of the system object interface. The uri for libiio always has the convention \"&lt; backend &gt;:&lt; address &gt;\", where backend can be ethernet, ip or usb. address will be specific to the backend. This is documented in the libiio API.</p> <p>Below is a basic example of setting up a generic ADC using an Ethernet/IP backend: <pre><code>rx = adi.ADxxxx.Rx;\nrx.uri = 'ip:analog.local';\ndata = rx();\n</code></pre> With the code above, the hardware is not contacted until the operator or step method is called on line 3. Therefore, any properties that are set or defined before line 3 are not applied or updated on the hardware until after line 3. However, after line 3 has completed the object will become locked and certain configuration changes cannot be applied after this point. These will primarily sample rates and buffer sizes.</p> <p>The state of the object follows the flow of the diagram below triggered by line 3 above.</p> <p>graph LR   Z[Operator Called] --&gt;A;   A[Connect To Board] --&gt; B[Update Properties];   B --&gt; C[Initialize Buffers];   C --&gt; D[Send or Receive Data];   D --&gt; E[Lock Object];  Once the object becomes locked it must be released if the sample rate or buffers need to be modified. This will disconnect from the hardware: <pre><code>rx.release(); % Release object\n</code></pre></p> <p>To provide a complete example we can do more advanced configuration like so to demonstrate property changes: <pre><code>rx = adi.ADxxxx.Rx;\nrx.uri = 'ip:analog.local';\nrx.SamplesPerFrame = 1024;\nrx.SampleRate = 256000;\ndata1 = rx();\n\n% Update tunable property\nrx.SampleRate = 128000;\ndata2 = rx();\n\n% Update non-tunable property\nrx.release();\nrx.SamplesPerFrame = 4096;\ndataLargerBuffer = rx();\n</code></pre></p>"},{"location":"_pages/streaming/#receiving-data","title":"Receiving Data","text":"<p>To receive or capture data from a given device first you must instantiate that device's interface class. For a generic ADC, this would be as follows:</p> <pre><code>rx = adi.ADxxxx.Rx;\n</code></pre> <p>Once instantiated you can configure the number of samples to be captured by setting the property SamplesPerFrame.</p> <pre><code>rx.SamplesPerFrame = 1e6;\n</code></pre> <p>SamplesPerFrame is the number of samples per channel which will be captured. If your device produces complex data (I and Q) this is the number of complex samples. There will be a limit to the maximum samples which can be collected. By default this is set to 2^20, but it may be possible to make it larger depending on hardware. Once the operator methods are used for a give instantiation, the object will become locked and the SamplesPerFrame property cannot be changed. This is known as a non-tunable property.</p> <p>To actually collect the samples or perform the capture, the operator of the system object should be used or the step method as so:</p> <pre><code>data = rx(); % Operator method\ndata = rx.step(); % Step method\n</code></pre> <p>Both method calls are equivalent, and the produced matrix data will be of size [SamplesPerFrame x length(EnabledChannels)]. EnabledChannels determines the channels which data will be collected from. EnabledChannels is a [1xN] vector with indexes starting at 1 of the desired channels. </p>"},{"location":"_pages/streaming/#continuous-data-acquisition","title":"Continuous Data Acquisition","text":"<p>If you are capturing multiple frames or buffers of data, then there might arise situations where discontinuities appear in the samples, when plotted. </p> <p>Some detail and tips are discussed in this wiki page on IIO System Considerations, Tips and Tricks</p> <p>The IIO buffer size is governed by the SamplesPerFrame property of the System Object classes. The kernelBuffersCount is also a property defined for the classes, and can be modified. </p>"},{"location":"_pages/support/","title":"Support","text":"<p>{% include 'header.tmpl' %}</p>"},{"location":"_pages/support/#support","title":"Support","text":"<p>Support is provided online through the EngineerZone forums. If you have questions related to the hardware itself outside of this BSP, contact your local FAE or ask on the forums.</p> <p>Question regarding specific aspect of the BSP should be asked in the following places:</p> <ul> <li>Software Interface Tools for questions on the BSP itself</li> <li>Linux Software Drivers for libiio and iio driver questions</li> </ul>"},{"location":"_pages/targeting/","title":"HDL Targeting with HDL-Coder","text":"<p>High-Speed Converter Toolbox supports the IP Core generation flow from MathWorks which allows for automated integration of DSP into HDL reference designs from Analog Devices. This workflow will take Simulink subsystems, run HDL-Coder to generate source Verilog, and then integrate that into a larger reference design. The figure below is a simplified block diagram of a SoC (Fabric+ARM) device, where specialized IP are inserted into the receive and transmit datapaths. This is supported on specific FPGA families and high-speed based reference designs. This support is based on the Zynq HDL-Coder and support</p> <p></p>"},{"location":"_pages/targeting/#recommended-review","title":"Recommended Review","text":"<ul> <li>Getting started with Zynq</li> </ul>"},{"location":"_pages/targeting/#getting-started","title":"Getting Started","text":"<p>To perform targeting will require FPGA vendor tools for the FPGA system. For Xilinx this will be Vivado and the toolbox will require specific versions for each release. For the current release this is Vivado 2019.1. Using other versions are not supported. To build the necessary BOOT.BIN files will require the Xilinx SDK as well.</p> <p>Once you have the installed the necessary 3rd party tools MATLAB needs to be told where they are installed by use of the hdlsetuptoolpath command. For Windows the following MATLAB command can be used:</p> <pre><code>hdlsetuptoolpath('ToolName', 'Xilinx Vivado', 'ToolPath', 'C:\\Xilinx\\Vivado\\2019.1\\bin\\vivado.bat');\n</code></pre> <p>or Linux:</p> <pre><code>hdlsetuptoolpath('ToolName', 'Xilinx Vivado', 'ToolPath', '/opt/Xilinx/Vivado/2019.1/bin/vivado');\n</code></pre> <p>Please change the tool path if it is different on your system.</p>"},{"location":"_pages/targeting/#checking-for-supported-designs","title":"Checking For Supported Designs","text":"<p>To verify that the ADI reference designs are available to HDL Workflow Advisor a Simulink model needs to be opened. To do so launch Simulink with the following command:</p> <pre><code>simulink\n</code></pre> <p>After it launches open a \"Blank DUT\" model from the \"HDL Coder\" dropdown of the Simulink Start Page.</p> <p></p> <p>After the model opens, click on the green subsystem to select it. Then open the \"Apps\" tap, open the apps menu and scroll down to HDL-Coder.</p> <p></p> <p>This will open the HDL-Coder menu, from here the Workflow Advisor is selectable. Click on it to launch the advisor.</p> <p></p> <p>Once launch go to Step 1.1 on the left side column. Then on the right side of the window select \"IP Core Generation\" for \"Target workflow\". Then the ADI reference designs should be available in the \"Target platform\" menu as so:</p> <p></p>"},{"location":"hdlrefdesigns/ad7380/","title":"ad7380 Reference Design Integration","text":"<p>This page outlines the HDL reference design integration for the ad7380 reference design for the Analog Devices AD7380 component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: </p> <ul> <li>Base reference design documentation</li> <li>Supported FPGA carriers:<ul> <li>ZCU102</li> </ul> </li> <li>Supported design variants:<ul> <li>RX</li> </ul> </li> </ul>"},{"location":"hdlrefdesigns/ad7380/#reference-design","title":"Reference Design","text":"HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. <p>The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above.</p>"},{"location":"hdlrefdesigns/ad7380/#hdl-worflow-advisor-port-mappings","title":"HDL Worflow Advisor Port Mappings","text":"<p>When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core:</p> Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant VALID-OUT IP Data Valid OUT axi_ad9680_cpack/fifo_wr_en 1 RX VALID-IN IP Valid Rx Data IN axi_ad9680_tpl/adc_valid_0 1 RX DATA-OUT IP Data 0 OUT axi_ad9680_cpack/fifo_wr_data_0 64 RX DATA-OUT IP Data 1 OUT axi_ad9680_cpack/fifo_wr_data_1 64 RX DATA-IN AD7380 ADC Data 0 IN axi_ad9680_tpl/adc_data_0 64 RX DATA-IN AD7380 ADC Data 1 IN axi_ad9680_tpl/adc_data_1 64 RX"},{"location":"hdlrefdesigns/ad7768/","title":"ad7768 Reference Design Integration","text":"<p>This page outlines the HDL reference design integration for the ad7768 reference design for the Analog Devices AD7768 component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: </p> <ul> <li>Base reference design documentation</li> <li>Supported FPGA carriers:<ul> <li>ZCU102</li> </ul> </li> <li>Supported design variants:<ul> <li>RX</li> </ul> </li> </ul>"},{"location":"hdlrefdesigns/ad7768/#reference-design","title":"Reference Design","text":"HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. <p>The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above.</p>"},{"location":"hdlrefdesigns/ad7768/#hdl-worflow-advisor-port-mappings","title":"HDL Worflow Advisor Port Mappings","text":"<p>When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core:</p> Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant VALID-OUT IP Data Valid OUT util_mxfe_cpack/fifo_wr_en 1 RX VALID-IN IP Valid Rx Data IN rx_mxfe_tpl_core/adc_valid_0 1 RX DATA-OUT IP Data 0 OUT util_mxfe_cpack/fifo_wr_data_0 16 RX DATA-OUT IP Data 1 OUT util_mxfe_cpack/fifo_wr_data_1 16 RX DATA-OUT IP Data 2 OUT util_mxfe_cpack/fifo_wr_data_2 16 RX DATA-OUT IP Data 3 OUT util_mxfe_cpack/fifo_wr_data_3 16 RX DATA-OUT IP Data 4 OUT util_mxfe_cpack/fifo_wr_data_4 16 RX DATA-OUT IP Data 5 OUT util_mxfe_cpack/fifo_wr_data_5 16 RX DATA-OUT IP Data 6 OUT util_mxfe_cpack/fifo_wr_data_6 16 RX DATA-OUT IP Data 7 OUT util_mxfe_cpack/fifo_wr_data_7 16 RX DATA-IN AD7768 ADC Data 0 IN rx_mxfe_tpl_core/adc_data_0 16 RX DATA-IN AD7768 ADC Data 1 IN rx_mxfe_tpl_core/adc_data_1 16 RX DATA-IN AD7768 ADC Data 2 IN rx_mxfe_tpl_core/adc_data_2 16 RX DATA-IN AD7768 ADC Data 3 IN rx_mxfe_tpl_core/adc_data_3 16 RX DATA-IN AD7768 ADC Data 4 IN rx_mxfe_tpl_core/adc_data_4 16 RX DATA-IN AD7768 ADC Data 5 IN rx_mxfe_tpl_core/adc_data_5 16 RX DATA-IN AD7768 ADC Data 6 IN rx_mxfe_tpl_core/adc_data_6 16 RX DATA-IN AD7768 ADC Data 7 IN rx_mxfe_tpl_core/adc_data_7 16 RX"},{"location":"hdlrefdesigns/adrv9002/","title":"adrv9002 Reference Design Integration","text":"<p>This page outlines the HDL reference design integration for the adrv9002 reference design for the Analog Devices ADRV9002 component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: </p> <ul> <li>Base reference design documentation</li> <li>Supported FPGA carriers:<ul> <li>ZCU102</li> </ul> </li> <li>Supported design variants:<ul> <li>RX</li> <li>TX</li> <li>RX &amp; TX</li> </ul> </li> </ul>"},{"location":"hdlrefdesigns/adrv9002/#reference-design","title":"Reference Design","text":"HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. <p>The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above.</p>"},{"location":"hdlrefdesigns/adrv9002/#hdl-worflow-advisor-port-mappings","title":"HDL Worflow Advisor Port Mappings","text":"<p>When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core:</p> Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant VALID-OUT IP Data Valid OUT util_adc_1_pack/fifo_wr_en 1 RX VALID-IN IP Valid Rx Data IN axi_adrv9001/adc_1_valid_i0 1 RX DATA-OUT IP Data 0 OUT util_adc_1_pack/fifo_wr_data_0 16 RX DATA-OUT IP Data 1 OUT util_adc_1_pack/fifo_wr_data_1 16 RX DATA-OUT IP Data 2 OUT util_adc_1_pack/fifo_wr_data_2 16 RX DATA-OUT IP Data 3 OUT util_adc_1_pack/fifo_wr_data_3 16 RX DATA-IN ADRV9002 ADC Data Q0 axi_adrv9001/adc_1_data_i0 16 RX DATA-IN ADRV9002 ADC Data I0 axi_adrv9001/adc_1_data_i1 16 RX DATA-IN ADRV9002 ADC Data Q0 axi_adrv9001/adc_1_data_q0 16 RX DATA-IN ADRV9002 ADC Data I0 axi_adrv9001/adc_1_data_q1 16 RX VALID-IN IP Valid Tx Data IN util_dac_1_upack/fifo_rd_valid 1 TX VALID-OUT IP Load Tx Data OUT util_dac_1_upack/fifo_rd_en 1 TX DATA-OUT ADRV9002 DAC Data Q0 axi_adrv9001/dac_1_data_i0 16 TX DATA-OUT ADRV9002 DAC Data I0 axi_adrv9001/dac_1_data_i1 16 TX DATA-OUT ADRV9002 DAC Data Q0 axi_adrv9001/dac_1_data_q0 16 TX DATA-OUT ADRV9002 DAC Data I0 axi_adrv9001/dac_1_data_q1 16 TX DATA-IN IP Data 0 IN util_dac_1_upack/fifo_rd_data_0 16 TX DATA-IN IP Data 1 IN util_dac_1_upack/fifo_rd_data_1 16 TX DATA-IN IP Data 2 IN util_dac_1_upack/fifo_rd_data_2 16 TX DATA-IN IP Data 3 IN util_dac_1_upack/fifo_rd_data_3 16 TX"},{"location":"hdlrefdesigns/adrv9009/","title":"adrv9009 Reference Design Integration","text":"<p>This page outlines the HDL reference design integration for the adrv9009 reference design for the Analog Devices ADRV9009 component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: </p> <ul> <li>Base reference design documentation</li> <li>Supported FPGA carriers:<ul> <li>ZCU102</li> </ul> </li> <li>Supported design variants:<ul> <li>RX</li> <li>TX</li> <li>RX &amp; TX</li> </ul> </li> </ul>"},{"location":"hdlrefdesigns/adrv9009/#reference-design","title":"Reference Design","text":"HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. <p>The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above.</p>"},{"location":"hdlrefdesigns/adrv9009/#hdl-worflow-advisor-port-mappings","title":"HDL Worflow Advisor Port Mappings","text":"<p>When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core:</p> Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant VALID-OUT IP Data Valid OUT util_adrv9009_rx_cpack/fifo_wr_en 1 RX VALID-IN IP Valid Rx Data IN rx_adrv9009_tpl_core/adc_valid_0 1 RX DATA-OUT IP Data 0 OUT util_adrv9009_rx_cpack/fifo_wr_data_0 16 RX DATA-OUT IP Data 1 OUT util_adrv9009_rx_cpack/fifo_wr_data_1 16 RX DATA-OUT IP Data 2 OUT util_adrv9009_rx_cpack/fifo_wr_data_2 16 RX DATA-OUT IP Data 3 OUT util_adrv9009_rx_cpack/fifo_wr_data_3 16 RX DATA-IN ADRV9009 ADC Data Q0 rx_adrv9009_tpl_core/adc_data_0 16 RX DATA-IN ADRV9009 ADC Data I0 rx_adrv9009_tpl_core/adc_data_1 16 RX DATA-IN ADRV9009 ADC Data Q1 rx_adrv9009_tpl_core/adc_data_2 16 RX DATA-IN ADRV9009 ADC Data I1 rx_adrv9009_tpl_core/adc_data_3 16 RX VALID-IN IP Valid Tx Data IN util_adrv9009_tx_upack/fifo_rd_valid 1 TX VALID-OUT IP Load Tx Data OUT util_adrv9009_tx_upack/fifo_rd_en 1 TX DATA-OUT ADRV9009 DAC Data Q0 tx_adrv9009_tpl_core/dac_data_0 16 TX DATA-OUT ADRV9009 DAC Data I0 tx_adrv9009_tpl_core/dac_data_1 16 TX DATA-OUT ADRV9009 DAC Data Q1 tx_adrv9009_tpl_core/dac_data_2 16 TX DATA-OUT ADRV9009 DAC Data I1 tx_adrv9009_tpl_core/dac_data_3 16 TX DATA-IN IP Data 0 IN util_adrv9009_tx_upack/fifo_rd_data_0 16 TX DATA-IN IP Data 1 IN util_adrv9009_tx_upack/fifo_rd_data_1 16 TX DATA-IN IP Data 2 IN util_adrv9009_tx_upack/fifo_rd_data_2 16 TX DATA-IN IP Data 3 IN util_adrv9009_tx_upack/fifo_rd_data_3 16 TX"},{"location":"hdlrefdesigns/adrv9361z7035/","title":"adrv9361z7035 Reference Design Integration","text":"<p>This page outlines the HDL reference design integration for the adrv9361z7035 reference design for the Analog Devices AD9361 component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: </p> <ul> <li>Base reference design documentation</li> <li>Supported FPGA carriers:<ul> <li>CCBOB_CMOS</li> <li>CCBOB_LVDS</li> <li>CCBOX_LVDS</li> <li>CCFMC_LVDS</li> <li>CCPACKRF_LVDS</li> </ul> </li> <li>Supported design variants:<ul> <li>RX</li> <li>TX</li> <li>RX &amp; TX</li> </ul> </li> </ul>"},{"location":"hdlrefdesigns/adrv9361z7035/#reference-design","title":"Reference Design","text":"HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. <p>The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above.</p>"},{"location":"hdlrefdesigns/adrv9361z7035/#hdl-worflow-advisor-port-mappings","title":"HDL Worflow Advisor Port Mappings","text":"<p>When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core:</p> Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant VALID-OUT IP Data Valid OUT util_ad9361_adc_pack/fifo_wr_en 1 RX VALID-IN IP Valid Rx Data IN util_ad9361_adc_fifo/dout_valid_0 1 RX DATA-OUT IP Data 0 OUT util_ad9361_adc_pack/fifo_wr_data_0 16 RX DATA-OUT IP Data 1 OUT util_ad9361_adc_pack/fifo_wr_data_1 16 RX DATA-OUT IP Data 2 OUT util_ad9361_adc_pack/fifo_wr_data_2 16 RX DATA-OUT IP Data 3 OUT util_ad9361_adc_pack/fifo_wr_data_3 16 RX DATA-IN AD9361 ADC Data Q0 util_ad9361_adc_fifo/dout_data_0 16 RX DATA-IN AD9361 ADC Data I0 util_ad9361_adc_fifo/dout_data_1 16 RX DATA-IN AD9361 ADC Data Q1 util_ad9361_adc_fifo/dout_data_2 16 RX DATA-IN AD9361 ADC Data I1 util_ad9361_adc_fifo/dout_data_3 16 RX VALID-IN IP Valid Tx Data IN util_ad9361_dac_upack/fifo_rd_valid 1 TX VALID-OUT IP Load Tx Data OUT axi_ad9361_dac_fifo/din_valid_in_0 1 TX DATA-OUT AD9361 DAC Data Q0 axi_ad9361_dac_fifo/din_data_0 16 TX DATA-OUT AD9361 DAC Data I0 axi_ad9361_dac_fifo/din_data_1 16 TX DATA-OUT AD9361 DAC Data Q1 axi_ad9361_dac_fifo/din_data_2 16 TX DATA-OUT AD9361 DAC Data I1 axi_ad9361_dac_fifo/din_data_3 16 TX DATA-IN IP Data 0 IN util_ad9361_dac_upack/fifo_rd_data_0 16 TX DATA-IN IP Data 1 IN util_ad9361_dac_upack/fifo_rd_data_1 16 TX DATA-IN IP Data 2 IN util_ad9361_dac_upack/fifo_rd_data_2 16 TX DATA-IN IP Data 3 IN util_ad9361_dac_upack/fifo_rd_data_3 16 TX"},{"location":"hdlrefdesigns/adrv9364z7020/","title":"adrv9364z7020 Reference Design Integration","text":"<p>This page outlines the HDL reference design integration for the adrv9364z7020 reference design for the Analog Devices AD9364 component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: </p> <ul> <li>Base reference design documentation</li> <li>Supported FPGA carriers:<ul> <li>CCBOB_CMOS</li> <li>CCBOB_LVDS</li> <li>CCBOX_LVDS</li> </ul> </li> <li>Supported design variants:<ul> <li>RX</li> <li>TX</li> <li>RX &amp; TX</li> </ul> </li> </ul>"},{"location":"hdlrefdesigns/adrv9364z7020/#reference-design","title":"Reference Design","text":"HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. <p>The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above.</p>"},{"location":"hdlrefdesigns/adrv9364z7020/#hdl-worflow-advisor-port-mappings","title":"HDL Worflow Advisor Port Mappings","text":"<p>When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core:</p> Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant VALID-OUT IP Data Valid OUT util_ad9361_adc_pack/fifo_wr_en 1 RX VALID-IN IP Valid Rx Data IN util_ad9361_adc_fifo/dout_valid_0 1 RX DATA-OUT IP Data 0 OUT util_ad9361_adc_pack/fifo_wr_data_0 16 RX DATA-OUT IP Data 1 OUT util_ad9361_adc_pack/fifo_wr_data_1 16 RX DATA-OUT IP Data 2 OUT util_ad9361_adc_pack/fifo_wr_data_2 16 RX DATA-OUT IP Data 3 OUT util_ad9361_adc_pack/fifo_wr_data_3 16 RX DATA-IN AD9364 ADC Data Q0 util_ad9361_adc_fifo/dout_data_0 16 RX DATA-IN AD9364 ADC Data I0 util_ad9361_adc_fifo/dout_data_1 16 RX DATA-IN AD9364 ADC Data Q1 util_ad9361_adc_fifo/dout_data_2 16 RX DATA-IN AD9364 ADC Data I1 util_ad9361_adc_fifo/dout_data_3 16 RX VALID-IN IP Valid Tx Data IN util_ad9361_dac_upack/fifo_rd_valid 1 TX VALID-OUT IP Load Tx Data OUT axi_ad9361_dac_fifo/din_valid_in_0 1 TX DATA-OUT AD9364 DAC Data Q0 axi_ad9361_dac_fifo/din_data_0 16 TX DATA-OUT AD9364 DAC Data I0 axi_ad9361_dac_fifo/din_data_1 16 TX DATA-OUT AD9364 DAC Data Q1 axi_ad9361_dac_fifo/din_data_2 16 TX DATA-OUT AD9364 DAC Data I1 axi_ad9361_dac_fifo/din_data_3 16 TX DATA-IN IP Data 0 IN util_ad9361_dac_upack/fifo_rd_data_0 16 TX DATA-IN IP Data 1 IN util_ad9361_dac_upack/fifo_rd_data_1 16 TX DATA-IN IP Data 2 IN util_ad9361_dac_upack/fifo_rd_data_2 16 TX DATA-IN IP Data 3 IN util_ad9361_dac_upack/fifo_rd_data_3 16 TX"},{"location":"hdlrefdesigns/adrv9371/","title":"adrv9371 Reference Design Integration","text":"<p>This page outlines the HDL reference design integration for the adrv9371 reference design for the Analog Devices AD9371 component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: </p> <ul> <li>Base reference design documentation</li> <li>Supported FPGA carriers:<ul> <li>ZC706</li> <li>ZCU102</li> </ul> </li> <li>Supported design variants:<ul> <li>RX</li> <li>TX</li> </ul> </li> </ul>"},{"location":"hdlrefdesigns/adrv9371/#reference-design","title":"Reference Design","text":"HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. <p>The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above.</p>"},{"location":"hdlrefdesigns/adrv9371/#hdl-worflow-advisor-port-mappings","title":"HDL Worflow Advisor Port Mappings","text":"<p>When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core:</p> Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant VALID-OUT IP Data Valid OUT util_ad9371_rx_cpack/fifo_wr_en 1 RX VALID-IN IP Valid Rx Data IN rx_ad9371_tpl_core/adc_valid_0 1 RX DATA-OUT IP Data 0 OUT util_ad9361_adc_pack/fifo_wr_data_0 16 RX DATA-OUT IP Data 1 OUT util_ad9361_adc_pack/fifo_wr_data_1 16 RX DATA-OUT IP Data 2 OUT util_ad9361_adc_pack/fifo_wr_data_2 16 RX DATA-OUT IP Data 3 OUT util_ad9361_adc_pack/fifo_wr_data_3 16 RX DATA-IN AD9371 ADC Data Q0 rx_ad9371_tpl_core/adc_data_0 16 RX DATA-IN AD9371 ADC Data I0 rx_ad9371_tpl_core/adc_data_1 16 RX DATA-IN AD9371 ADC Data Q1 rx_ad9371_tpl_core/adc_data_2 16 RX DATA-IN AD9371 ADC Data I1 rx_ad9371_tpl_core/adc_data_3 16 RX VALID-IN IP Valid Tx Data IN util_ad9371_tx_upack/fifo_rd_valid 1 TX VALID-OUT IP Load Tx Data OUT util_ad9371_tx_upack/fifo_rd_en 1 TX DATA-OUT AD9371 DAC Data Q0 tx_ad9371_tpl_core/dac_data_0 32 TX DATA-OUT AD9371 DAC Data I0 tx_ad9371_tpl_core/dac_data_1 32 TX DATA-OUT AD9371 DAC Data Q1 tx_ad9371_tpl_core/dac_data_2 32 TX DATA-OUT AD9371 DAC Data I1 tx_ad9371_tpl_core/dac_data_3 32 TX DATA-IN IP Data 0 IN util_ad9371_tx_upack/fifo_rd_data_0 32 TX DATA-IN IP Data 1 IN util_ad9371_tx_upack/fifo_rd_data_1 32 TX DATA-IN IP Data 2 IN util_ad9371_tx_upack/fifo_rd_data_2 32 TX DATA-IN IP Data 3 IN util_ad9371_tx_upack/fifo_rd_data_3 32 TX"},{"location":"hdlrefdesigns/daq2/","title":"daq2 Reference Design Integration","text":"<p>This page outlines the HDL reference design integration for the daq2 reference design for the Analog Devices AD9680 and AD9144 component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: </p> <ul> <li>Base reference design documentation</li> <li>Supported FPGA carriers:<ul> <li>ZC706</li> <li>ZCU102</li> </ul> </li> <li>Supported design variants:<ul> <li>RX</li> <li>TX</li> <li>RX &amp; TX</li> </ul> </li> </ul>"},{"location":"hdlrefdesigns/daq2/#reference-design","title":"Reference Design","text":"HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. <p>The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above.</p>"},{"location":"hdlrefdesigns/daq2/#hdl-worflow-advisor-port-mappings","title":"HDL Worflow Advisor Port Mappings","text":"<p>When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core:</p> Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant VALID-OUT IP Data Valid OUT util_ad9680_cpack/fifo_wr_en 1 RX VALID-IN IP Valid Rx Data IN rx_ad9680_tpl_core/adc_valid_0 1 RX DATA-OUT IP Data 0 OUT util_ad9680_cpack/fifo_wr_data_0 16 RX DATA-OUT IP Data 1 OUT util_ad9680_cpack/fifo_wr_data_1 16 RX DATA-OUT IP Data 2 OUT util_ad9680_cpack/fifo_wr_data_2 16 RX DATA-OUT IP Data 3 OUT util_ad9680_cpack/fifo_wr_data_3 16 RX DATA-IN AD9680 and AD9144 ADC Data Q0 rx_ad9680_tpl_core/adc_data_0 16 RX DATA-IN AD9680 and AD9144 ADC Data I0 rx_ad9680_tpl_core/adc_data_1 16 RX DATA-IN AD9680 and AD9144 ADC Data Q1 rx_ad9680_tpl_core/adc_data_2 16 RX DATA-IN AD9680 and AD9144 ADC Data I1 rx_ad9680_tpl_core/adc_data_3 16 RX VALID-IN IP Valid Tx Data IN util_ad9144_upack/fifo_rd_valid 1 TX VALID-OUT IP Load Tx Data OUT util_ad9144_upack/fifo_rd_en 1 TX DATA-OUT AD9680 and AD9144 DAC Data Q0 ad9144_tpl_core/dac_data_0 16 TX DATA-OUT AD9680 and AD9144 DAC Data I0 ad9144_tpl_core/dac_data_1 16 TX DATA-OUT AD9680 and AD9144 DAC Data Q1 ad9144_tpl_core/dac_data_2 16 TX DATA-OUT AD9680 and AD9144 DAC Data I1 ad9144_tpl_core/dac_data_3 16 TX DATA-IN IP Data 0 IN util_ad9144_upack/fifo_rd_data_0 16 TX DATA-IN IP Data 1 IN util_ad9144_upack/fifo_rd_data_1 16 TX DATA-IN IP Data 2 IN util_ad9144_upack/fifo_rd_data_2 16 TX DATA-IN IP Data 3 IN util_ad9144_upack/fifo_rd_data_3 16 TX"},{"location":"hdlrefdesigns/fmcomms2/","title":"fmcomms2 Reference Design Integration","text":"<p>This page outlines the HDL reference design integration for the fmcomms2 reference design for the Analog Devices AD9361 component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: </p> <ul> <li>Base reference design documentation</li> <li>Supported FPGA carriers:<ul> <li>ZED</li> <li>ZC706</li> <li>ZC702</li> </ul> </li> <li>Supported design variants:<ul> <li>RX</li> <li>TX</li> <li>RX &amp; TX</li> </ul> </li> </ul>"},{"location":"hdlrefdesigns/fmcomms2/#reference-design","title":"Reference Design","text":"HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. <p>The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above.</p>"},{"location":"hdlrefdesigns/fmcomms2/#hdl-worflow-advisor-port-mappings","title":"HDL Worflow Advisor Port Mappings","text":"<p>When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core:</p> Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant VALID-OUT IP Data Valid OUT util_ad9361_adc_pack/fifo_wr_en 1 RX VALID-IN IP Valid Rx Data IN util_ad9361_adc_fifo/dout_valid_0 1 RX DATA-OUT IP Data 0 OUT util_ad9361_adc_pack/fifo_wr_data_0 16 RX DATA-OUT IP Data 1 OUT util_ad9361_adc_pack/fifo_wr_data_1 16 RX DATA-OUT IP Data 2 OUT util_ad9361_adc_pack/fifo_wr_data_2 16 RX DATA-OUT IP Data 3 OUT util_ad9361_adc_pack/fifo_wr_data_3 16 RX DATA-IN AD9361 ADC Data Q0 util_ad9361_adc_fifo/dout_data_0 16 RX DATA-IN AD9361 ADC Data I0 util_ad9361_adc_fifo/dout_data_1 16 RX DATA-IN AD9361 ADC Data Q1 util_ad9361_adc_fifo/dout_data_2 16 RX DATA-IN AD9361 ADC Data I1 util_ad9361_adc_fifo/dout_data_3 16 RX VALID-IN IP Valid Tx Data IN util_ad9361_dac_upack/fifo_rd_valid 1 TX VALID-OUT IP Load Tx Data OUT axi_ad9361_dac_fifo/din_valid_in_0 1 TX DATA-OUT AD9361 DAC Data Q0 axi_ad9361_dac_fifo/din_data_0 16 TX DATA-OUT AD9361 DAC Data I0 axi_ad9361_dac_fifo/din_data_1 16 TX DATA-OUT AD9361 DAC Data Q1 axi_ad9361_dac_fifo/din_data_2 16 TX DATA-OUT AD9361 DAC Data I1 axi_ad9361_dac_fifo/din_data_3 16 TX DATA-IN IP Data 0 IN util_ad9361_dac_upack/fifo_rd_data_0 16 TX DATA-IN IP Data 1 IN util_ad9361_dac_upack/fifo_rd_data_1 16 TX DATA-IN IP Data 2 IN util_ad9361_dac_upack/fifo_rd_data_2 16 TX DATA-IN IP Data 3 IN util_ad9361_dac_upack/fifo_rd_data_3 16 TX"},{"location":"hdlrefdesigns/pluto/","title":"pluto Reference Design Integration","text":"<p>This page outlines the HDL reference design integration for the pluto reference design for the Analog Devices AD9361 component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: </p> <ul> <li>Base reference design documentation</li> <li>Supported FPGA carriers:</li> <li>Supported design variants:<ul> <li>RX</li> <li>TX</li> </ul> </li> </ul>"},{"location":"hdlrefdesigns/pluto/#reference-design","title":"Reference Design","text":"HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. <p>The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above.</p>"},{"location":"hdlrefdesigns/pluto/#hdl-worflow-advisor-port-mappings","title":"HDL Worflow Advisor Port Mappings","text":"<p>When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core:</p> Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant VALID-OUT IP Data Valid OUT cpack/fifo_wr_en 1 RX VALID-IN IP Valid Rx Data IN axi_ad9361/adc_valid_i0 1 RX DATA-OUT IP Data 0 OUT cpack/fifo_wr_data_0 16 RX DATA-OUT IP Data 1 OUT cpack/fifo_wr_data_1 16 RX DATA-IN AD9361 ADC Data Q0 axi_ad9361/adc_data_i0 16 RX DATA-IN AD9361 ADC Data Q0 axi_ad9361/adc_data_q0 16 RX VALID-IN IP Valid Tx Data IN tx_upack/fifo_rd_valid 1 TX VALID-OUT IP Load Tx Data OUT logic_or/Op1 1 TX DATA-OUT AD9361 DAC Data Q0 axi_ad9361/dac_data_i0 16 TX DATA-OUT AD9361 DAC Data Q0 axi_ad9361/dac_data_q0 16 TX DATA-IN IP Data 0 IN util_ad9361_dac_upack/fifo_rd_data_0 16 TX DATA-IN IP Data 1 IN util_ad9361_dac_upack/fifo_rd_data_1 16 TX"},{"location":"models/ad9081/adc.tex/","title":"AD9081 ADC and ADC Mux","text":"<p>The pipelined ADC models are simplified behavioral implementations that are based on the currently estimated specifications of the data converters. They are designed to be similar to the noise spectral density (NSD) of the converters. Note that since physical hardware does not exist these are estimated values and will likely change. There will be other distortions introduce by physical hardware as well, relating to front-end matches, internal chip structures, baluns, and gains stages among others. The ADC model should be considered similar but not exact.</p>"},{"location":"models/ad9081/adc.tex/#top-level-control","title":"Top-Level Control","text":"<p>There are two control properties related to ADC control: SampleRate and Crossbar4x4Mux0.</p> <p>SampleRate is the data rate of the converters themselves. Therefore, the output datarate of the model will be this SampleRate divided by the different decimations used.</p> <pre><code>help adi.sim.AD9081.Rx.SampleRate\n</code></pre> <pre><code>  SampleRate Sample Rate of ADCs\n    Scalar in Hz. Currently this is fixed since NSD will change\n    with this number, which would make the model invalid\n</code></pre> <p>Crossbar4x4Mux0 is a full crossbar mux connecting the ADCs to the rest of the system.</p> <pre><code>help adi.sim.AD9081.Rx.Crossbar4x4Mux0\n</code></pre> <pre><code>  Crossbar4x4Mux0 Crossbar 4x4 Mux0\n    Array of input and output mapping. Index is the output and the\n    value is the selected input\n</code></pre>"},{"location":"models/ad9081/adc.tex/#example-configuration","title":"Example Configuration","text":"<p>Here is a basic example were we want to map ADC0, ADC1, and ADC2 out only.</p> <pre><code>rx = adi.sim.AD9081.Rx;\nrx.SampleRate = 4e9;\nrx.Crossbar4x4Mux0 = [1,1,3,4];\n% Pass noise through model at 10% and 1% fullscale\nnoiseVolts1 = 1.4/2*0.1*randn(1000,1);\nnoiseVolts2 = 1.4/2*0.01*randn(1000,1);\n[o1,o2,~,~,o3,o4] = rx(noiseVolts1,noiseVolts2,noiseVolts1,noiseVolts1);\nouts = [o1,o2,o3,o4];\nfprintf('Mapped values identical %d\\n',isequal(outs(:,1),outs(:,2)))\n</code></pre> <pre><code>Mapped values identical 1\n</code></pre> <pre><code>fprintf('Mapped values identical %d\\n',isequal(outs(:,3),outs(:,4)))\n</code></pre> <pre><code>Mapped values identical 0\n</code></pre>"},{"location":"models/ad9081/dac.tex/","title":"AD9081 DAC","text":"<p>The DAC models are simplified behavioral implementations that are based on the currently estimated specifications of the data converters. They are designed to match the noise spectral density (NSD). Note that since physical hardware does not exist these are estimated values and will likely change by a few dB.</p>"},{"location":"models/ad9081/dac.tex/#top-level-control","title":"Top-Level Control","text":"<p>There are one control properties related to the DACs: SampleRate.</p> <p>SampleRate is the data rate of the converters themselves. Therefore, the input datarate of the model will be this SampleRate divided by the different interpolations used.</p> <pre><code>help adi.sim.AD9081.Tx.SampleRate\n</code></pre> <pre><code>  SampleRate Sample Rate of DACs\n    Scalar in Hz\n InverseSincGainAdjustDB Inverse Gain Adjust DB\n    Add gain to the output signal filter. Gain is in dB and can\n    only be &gt;=0 but &lt;=8.7040.  This will be internally quantized \n    based on the 8-bit allowed values with steps of 0.034dB.\n</code></pre>"},{"location":"models/ad9081/ddc2.tex/","title":"AD9081 Digital Down Converters","text":"<p>The AD9081 has two sets of digital down converters (DDC), the coarse (CDDC) and fine (FDDC), both following the ADC and PFILTs. These are used to both decimate and move signals using the NCOs. They also can be used to phase shift and apply gain to the input signal.</p> <p>The CDDCs and FDDC are almost identical except for their available decimations, allowable rates, and count. There are two CDDCs per ADC pair and four FDDCs per ADC pair. In the data pipeline, data from the ADCs will be passed through the CDDCs, or bypass the CDDCs, then routed through a mux into the FDDCs, which can also be bypassed.</p>"},{"location":"models/ad9081/ddc2.tex/#top-level-control","title":"Top-Level Control","text":"<p>The CDDC and FDDC decimations are controlled by MainDataPathDecimation and ChannelizerPathDecimation respectively.</p> <pre><code>help adi.sim.AD9081.Rx.MainDataPathDecimation\n</code></pre> <pre><code>  MainDataPathDecimation Main Data Path Decimation\n    Specify the decimation in the main data path which can be\n    [1,2,3,4,6]\n</code></pre> <pre><code>help adi.sim.AD9081.Rx.ChannelizerPathDecimation\n</code></pre> <pre><code>  ChannelizerPathDecimation Channelizer Path Decimation\n    Specify the decimation in the channelizer path which can be\n    [1,2,3,4,6,8,12,16,24]\n</code></pre>"},{"location":"models/ad9081/ddc2.tex/#muxing","title":"Muxing","text":"<p>The CDDC pairs share a common full crossbar to the four downstream FDDCs connected to them. This is represented by a single crossbar that limits routes to the halves of AD9081. This crossbar or mux is controlled by the Crossbar4x8Mux2 and will constrain all the mappings.</p> <pre><code>help adi.sim.AD9081.Rx.Crossbar4x8Mux2\n</code></pre> <pre><code>  Crossbar4x8Mux2 Crossbar 4x8 Mux2\n    Array of input and output mapping. Index is the output and the\n    value is the selected input (values should not exceed 4)\n</code></pre>"},{"location":"models/ad9081/ddc2.tex/#nco-mixer-enable-and-modes","title":"NCO Mixer Enable and Modes","text":"<p>If the NCOs need to be used they must be individually enabled through the CDDCNCOEnable and FDDCNCOEnable properties, which are both arrays of booleans. </p> <pre><code>help adi.sim.AD9081.Rx.CDDCNCOEnable\n</code></pre> <pre><code>  CDDCNCOEnable CDDC NCO Enable\n    1x4 Array of booleans to enable NCOs in main data path\n</code></pre> <pre><code>help adi.sim.AD9081.Rx.FDDCNCOEnable\n</code></pre> <pre><code>  FDDCNCOEnable FDDC NCO Enable\n    1x4 Array of booleans to enable NCOs in channelizer path\n</code></pre>"},{"location":"models/ad9081/ddc2.tex/#nco-frequency-and-phase","title":"NCO Frequency and Phase","text":"<p>Once the NCOs are enabled the frequencies and phases of the NCOs can be controlled individually. This is done through the CDDCNCOFrequencies, FDDCNCOFrequencies, CDDCNCOPhases, and FDDCNCOPhases. The frequencies will be limited based on the rate going into the NCO at that stage. Note that both the frequency and phase values are internally quantized to 48-bits based on the effective range of the NCO based on the sample rate into a given stage.</p> <pre><code>help adi.sim.AD9081.Rx.CDDCNCOFrequencies\n</code></pre> <pre><code>  CDDCNCOFrequencies CDDC NCO Frequencies\n    1x4 Array of frequencies of NCOs in main data path\n</code></pre> <pre><code>help adi.sim.AD9081.Rx.FDDCNCOFrequencies\n</code></pre> <pre><code>  FDDCNCOFrequencies FDDC NCO Frequencies\n    1x8 Array of frequencies of NCOs in channelizer path\n</code></pre>"},{"location":"models/ad9081/ddc2.tex/#example-configuration","title":"Example Configuration","text":"<p>The example below take a single input tone and shifts it into separate channels using the CDDC NCOs.</p> <pre><code>rx = adi.sim.AD9081.Rx;\n% Enable 3 NCOs to shift single into different bands\nrx.MainDataPathDecimation = 4;\nrx.CDDCNCOEnable = [true,true,true,false];\nrx.CDDCNCOFrequencies = [5e7,-3e7,1e8,0];\nrx.Crossbar4x8Mux2 = [1,2,1,2,3,4,3,4];\n% Create sinewave input\nsw = dsp.SineWave;\nsw.Amplitude = 1.4*0.5;\nsw.Frequency = 100e6;\nsw.SampleRate = rx.SampleRate;\nsw.SamplesPerFrame = 4e4;\ndata = sw();\n[o1,o2,~,~,o5,o6] = rx(data,data,data,data);\noutputCodes = [o1,o2,o5,o6];\n% Plot spectrum\nNfft = length(outputCodes); \nfullscale = 2^15; fs = rx.SampleRate/4;\nwin = kaiser(Nfft,100);\nwin = win/sum(win);\nwin = win*Nfft;\noutputCodes = double(outputCodes).*win;\nspec = fft(outputCodes) / Nfft;\nspec_db = 20*log10(abs(spec)/fullscale+10^-20);\ndf = fs/Nfft;  freqRangeRx = (-fs/2:df:fs/2-df).';\nplot(freqRangeRx,fftshift(spec_db));\nlegend('CDDC0','CDDC1','CDDC2','CDDC3')\nxlabel('Frequency (Hz)');ylabel('Magnitude (dBFS)');\n</code></pre> <p></p>"},{"location":"models/ad9081/duc.tex/","title":"AD9081 Digital Up Converters","text":"<p>The AD9081 has two sets of digital up converters (DUC), the coarse (CDUC) and fine (FDUC). These are used to both interpolate and move signals using the NCOs. They also can be used to phase shift and apply gain to the input signal.</p> <p>The CDUCs and FDUC are almost identical except for their available interpolations, allowable rates, and count. There are two CDUCs per DAC pair and four FDUCs per DAC pair. In the data pipeline, data from the input will be passed through the FDUCs, or bypass the FDUCs, then routed through a mux into the CDUCs, which can also be bypassed.</p>"},{"location":"models/ad9081/duc.tex/#top-level-control","title":"Top-Level Control","text":"<p>The CDUC and FDUC interpolations are controlled by MainDataPathInterpolation and ChannelizerPathInterpolation respectively.</p> <pre><code>help adi.sim.AD9081.Tx.MainDataPathInterpolation\n</code></pre> <pre><code>  MainDataPathInterpolation Main Data Path Interpolation\n    Specify the decimation in the main data path which can be\n    [1,2,3,4,6]\n</code></pre> <pre><code>help adi.sim.AD9081.Tx.ChannelizerPathInterpolation\n</code></pre> <pre><code>  ChannelizerPathInterpolation Channelizer Path Interpolation\n    Specify the decimation in the channelizer path which can be\n    [1,2,3,4,6,8,12,16,24]\n</code></pre>"},{"location":"models/ad9081/duc.tex/#muxing","title":"Muxing","text":"<p>The FDUC quads share a common full crossbar to the pairs of upstream CDUCs connected to them. This is represented by a single summing crossbar that limits routes to the halves of AD9081. This crossbar or mux is controlled by the Crossbar8x8Mux and will constrain all the mappings.</p> <pre><code>help adi.sim.AD9081.Tx.Crossbar8x8Mux\n</code></pre> <pre><code>  Crossbar8x8Mux Crossbar 8x8 Mux\n    Logical 4x8 array of for MainDataPath input summers. Each row\n    corresponds to each summmer [1-4] and each column corresponds\n    to an input Channelizer path 1-8]. Set indexes to true to\n    enable a given path to be added into summer's output.\n</code></pre> <p>The 8x8 summing crossbar can sum any channels within the FDUC quads (FDUC0-&gt;FDUC3 and FDUC4-&gt;FDUC7). This is controlled by the columns of Crossbar8x8Mux, where each true row in a given column is feed into the individual summers feeding the inputs to the CDUCs. Below is an example of summing FDUC0,FDUC1,FDUC3 to CDDC0 and  FDUC4,FDUC5 to CDDC2:</p> <pre><code>tx = adi.sim.AD9081.Tx;\ntx.Crossbar8x8Mux = [...\n1,0,0,0,0,0,0,0;...FDUC0-&gt;CDUC0\n0,1,0,0,0,0,0,0;...FDUC1-&gt;CDUC1\n0,0,1,0,0,0,0,0;...FDUC2-&gt;CDUC2\n0,0,0,1,0,0,0,0]; %FDUC3-&gt;CDUC3\n</code></pre>"},{"location":"models/ad9081/duc.tex/#nco-frequency-and-phase","title":"NCO Frequency and Phase","text":"<p>Once the NCOs are enabled the frequencies and phases of the NCOs can be controlled individually. This is done through the CDUCNCOFrequencies, FDUCNCOFrequencies, CDUCNCOPhases, and FDUCNCOPhases. The frequencies will be limited based on the rate going into the NCO at that stage.</p> <pre><code>help adi.sim.AD9081.Tx.CDUCNCOFrequencies\n</code></pre> <pre><code>  CDUCNCOFrequencies CDUC NCO Frequencies\n    1x4 Array of frequencies of NCOs in main data path\n</code></pre> <pre><code>help adi.sim.AD9081.Tx.FDUCNCOFrequencies\n</code></pre> <pre><code>  FDUCNCOFrequencies FDUC NCO Frequencies\n    1x8 Array of frequencies of NCOs in channelizer path\n</code></pre>"},{"location":"models/ad9081/pfilt.tex/","title":"AD9081 Programmable FIR Filters (PFILT)","text":"<p>Following the ADCs are the Programmable FIRs (PFILTs) that can operate at maximum rates of the RX paths. The PFILTs are useful for channel equalization, image rejection, and generic filtering. The PFILTs also act as muxes into the CDDCs connected downstream on the RX path.</p> <p>There are two PFILT blocks per AD9081 which operate on pairs of ADCs. The ADC pairs can be individually muxed based on requirements with Mux0</p>"},{"location":"models/ad9081/pfilt.tex/#top-level-control","title":"Top-Level Control","text":"<p>RX has a pair of PFILT each which are denoted by PFilterX, where X is 1 or 2 in the property listing. Therefore RX will have properties: PFilterXMode, PFilterXTaps, and PFilterXGains.</p>"},{"location":"models/ad9081/pfilt.tex/#operational-modes-and-features","title":"Operational Modes and Features","text":"<p>Each PFILT block is fundamentally a large 192 tap filter which can be split into:</p> <ul> <li>1 192 tap filter </li> <li>2 96 tap filters </li> <li>3 64 tap filters (Matrix filter only) </li> <li>4 48 tap filters </li> </ul> <p>The filters are individually mapped to pairs of ADCs on the RX side based on the mode used. The PFILTs have eight configuration modes and the following notation will be used to describe the filtering modes:</p> <ul> <li>x1: first input </li> <li>x2: second input </li> <li>y1: first output </li> <li>y2: second output </li> <li>F1: filter 1 </li> <li>F2: filter 2 </li> <li>F3: filter 3 </li> <li>F4: filter 4 </li> <li>p: length of filters (individually) </li> </ul> <p>The different operational modes selectable through the PFilterXMode property are:</p> <ul> <li>NoFilter: y1 = x1, y2 = x2, y3 = x2, y4 = x2 </li> <li>SingleInphase: y1 = F1(x1), y2 = x2 </li> <li>SingleQuadrature: y1 = x1, y2 = F1(x2) </li> <li>DualReal: y1 = F1(x1), y2 = F2(x2) </li> <li>HalfComplexSumInphase: y1 = F1(x1)+F2(x1), y2 = x2*z^-p </li> <li>HalfComplexSumQuadrature: y2 = F1(x1)+F2(x1), y1 = x1*z^-p </li> <li>FullComplex: y1 = F1(x1)-F3(x2), y2 = F1(x1)+F3(x2)-F2(x1+x2)  </li> <li>Matrix: y1 = F1(x1) - F3(x2), y2 = F2(x1) - F4(x2) </li> </ul>"},{"location":"models/ad9081/pfilt.tex/#example-configuration","title":"Example Configuration","text":"<p>Here is a basic example of a moving average filter applied on the RX path on one of the four ADCs.</p> <pre><code>rx = adi.sim.AD9081.Rx;\nrx.PFIREnable = 1;\nrx.PFilter1Mode = 'SingleInphase';\nrx.PFilter2Mode = 'NoFilter';\nN = 48; rx.PFilter1Taps = [ones(1,N)./2^3,zeros(1,192-N)];\nrx.PFilter1TapsWidthsPerQuad = [...\n16,16,16,16,16,16,16,16,16,16,16,16,...\n12,12,12,12,12,12,12,12,12,12,12,12,...\n6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6];...\nrampVolts = 1.0*[(1./1e3.*(1:1e3)).';(1./1e3.*(1e3:-1:1)).'];\nrampVolts = randn(size(rampVolts))./16+rampVolts;\n[out1,out2,~,~,out3,out4] = rx(rampVolts,rampVolts,rampVolts,rampVolts);\nouts = [out1,out2,out3,out4];\nn = 1:2e3;\nsubplot(2,1,1);plot(n,real(outs(:,1)));title(\"Moving Average Filter\")\nsubplot(2,1,2);plot(n,real(outs(:,2)));title(\"No Filter\")\n</code></pre> <p></p>"},{"location":"models/ad9081/top_level.tex/","title":"AD9081 Behavioral Model Introduction","text":"<p>The AD9081 is a highly integrated RF mixed-signal front-end (MxFE) that features four 16-bit, 12 GSPS DAC cores and four 12-bit, 4 GSPS ADC cores, as shown below:</p> <p></p> <p>The device includes an optional on-chip clock multiplier (up to 12GHz) for DAC and ADC sampling clock generation as well as broadband ADC and DAC cores.</p> <p>The transmit and receive digital datapaths are highly configurable and support a wide range of single-band and multiband applications with varying RF bandwidth requirements. The AD9081 transmit and receive datapaths consist of four main datapaths in support of wideband signals and eight channelizers in support of narrower band signals. For multiband applications with wide separation between RF bands, the channelizers can be used to process the individual RF bands to reduce the overall complex data rate needed to represent each narrower band. Both the main and channelizer datapath stages offer flexible interpolating and decimation factors to allow a more manageable data interface rate aligned to the actual signal bandwidth requirements. The numerically controlled oscillator of each stage can be independently tuned for maximum flexibility.</p> <p>The models available in the High-Speed Converter Toolbox are designed to educate users on the configuration, features, and limitations of the AD9081. However, it should not be expected to match hardware exactly, but be similar in behavior. It should not be used for exact performance measurements.</p> <p>The device model is split into two components, one modeling the transmit path and one for the receive path. Both are System Objects and have methods and properties to allow configuration and passing of data into the models. For details on the different features select from the links below. For a basic overview of the models go to the \\hyperref{H_C9E8316D}{Quick Start} section below.</p> <ul> <li>ADC and ADC Mux </li> <li>DAC </li> <li>Programmable FIR Filters (PFILT) </li> <li>Digital Down Converters </li> <li>Digital Up Converters </li> </ul>"},{"location":"models/ad9081/top_level.tex/#model-limitations","title":"Model Limitations","text":"<p>The models are primarily designed to expose the DSP features of AD9081 and the different configurations possible. This does not include the JESD interfaces or highly detailed implementation of the ADCs or DACs within the device. However, the converter models will have similar NSD performance of the device.</p>"},{"location":"models/ad9081/top_level.tex/#quick-start","title":"Quick Start","text":"<p>Each TX and RX model instance can be instantiated like any other System Object in MATLAB through the constructor call. The constructor can be used to parameterize the model but it is typically more understandable to do this separately from the constructor as below:</p> <pre><code>rx = adi.sim.AD9081.Rx; % Call constructor of Receiver model\nrx.MainDataPathDecimation = 4; % Set CDDC decimation to 4\n% Call constructor with arguments\nrx = adi.sim.AD9081.Rx('MainDataPathDecimation',4);\n</code></pre> <p>The receiver model has dozens of properties and are set in a similar way to the above MainDataPathDecimation. These properties are validated when update and at runtime so the model will not run in an undefined mode.</p> <p>On receive, the input data is assumed to be in volts and the output of the model will be in codes. Note that these are not strictly ADC codes depending on what processing is enable inside.</p> <p>We can demonstrate a typical usage flow of the receiver through a few examples. In the below example feeds a 50% fullscale and 110% fullscale signal into the four ADCs in the form of a matrix. The input to the RX model must always be a 4 real Nx1 arrays of type double, representing the input to each ADC. N must be a multiple of the total decimation enable  and should be relatively large for performance reasons.</p> <pre><code>rx = adi.sim.AD9081.Rx;\n% Create sinewave at 50% FSR\nsw = dsp.SineWave;\nsw.Amplitude = 0.125; % volts\nsw.Frequency = 10e6;\nsw.SampleRate = rx.SampleRate;\nsw.SamplesPerFrame = 4e4;\ndata = sw();\noutputCodes = rx(data.*0.5,data.*0.5,data.*0.5,data.*1.1);\n% Plots\nplot(real(outputCodes));xlabel('Sample');ylabel('Code');\n</code></pre> <p></p> <p>On the TX side the usage model is the same, but we are instead passing integers to be transmitted from the DACs and the outputs are codes to the relative fullscale of the DAC which is 16-bits.</p> <pre><code>tx = adi.sim.AD9081.Tx;\ntx.MainDataPathInterpolation = 2;\ntx.ModeSelectMux = 0; % Set DAC inputs to real data from CDUCs.\n% Create sinewave at 50% and 25% FSR\nsw = dsp.SineWave;\nsw.Amplitude = 2^15*0.5; % codes\nsw.Frequency = 10e6;\nsw.SampleRate = rx.SampleRate;\nsw.SamplesPerFrame = 4e4;\ndataS = sw();\ndata = int16(dataS);dataHalf = int16(dataS.*0.5);\n[outputCodes0,~,~,outputCodes3] = tx(data,data,data,dataHalf,data,data,data,data);\n% Plots\nplot(real(outputCodes0)); hold on;\nplot(real(outputCodes3)); hold off;\nxlabel('Sample');ylabel('Code');\n</code></pre> <p></p>"},{"location":"models/ad9081/top_level.tex/#inspecting-properties","title":"Inspecting Properties","text":"<p>When using the model individual properties can be inspected for their functionality. Leveraging the help command will print out useful information on each setting. Follow the patterns below to perform lookups:</p> <pre><code>help adi.sim.AD9081.Rx.MainDataPathDecimation\n</code></pre> <pre><code>  MainDataPathDecimation Main Data Path Decimation\n    Specify the decimation in the main data path which can be\n    [1,2,3,4,6]\n</code></pre> <pre><code>rx = adi.sim.AD9081.Rx\n</code></pre> <pre><code>rx = \n  adi.sim.AD9081.Rx with properties:\n\n           CDDCNCOFrequencies: [1000000 1000000 1000000 1000000]\n                CDDCNCOEnable: [0 0 0 0]\n           FDDCNCOFrequencies: [1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000]\n                FDDCNCOEnable: [0 0 0 0 0 0 0 0]\n       MainDataPathDecimation: 1\n    ChannelizerPathDecimation: 1\n              Crossbar4x4Mux0: [1 2 3 4]\n              Crossbar4x8Mux2: [1 2 1 2 3 4 3 4]\n                   PFIREnable: false\n               ModeSelectMux1: false\n                   SampleRate: 4.0000e+09\n</code></pre> <pre><code>help rx.MainDataPathDecimation\n</code></pre> <pre><code>--- help for adi.sim.AD9081.Rx/MainDataPathDecimation ---\n\n  MainDataPathDecimation Main Data Path Decimation\n    Specify the decimation in the main data path which can be\n    [1,2,3,4,6]\n</code></pre>"},{"location":"sysobjects/adi.AD2S1210.Rx/","title":"adi.AD2S1210.Rx","text":"adi.AD2S1210.Rx Receives data from the AD2S1210 Resolver    The adi.AD2S1210.Rx System object is a signal source that can receive    data from the AD2S1210.     rx = adi.AD2S1210.Rx;    rx = adi.AD2S1210.Rx('uri','192.168.2.1'); AD2S1210 Datasheet Creation <p>The class can be instantiated in the following way with and without property name value pairs.</p> <pre><code>dev = adi.AD2S1210.Rx\ndev = adi.AD2S1210.Rx(Name, Value)\n</code></pre> Properties  Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them.  If a property is tunable, you can change its value at any time.  For more information on changing property values, see System Design in MATLAB Using System Objects. Angle + <p>Resolver angle in Degrees.</p> AngleScale + <p>Resolver angle scale.</p> EnabledChannels + <p>Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant</p> SamplesPerFrame + <p>Number of samples per frame, specified as an even positive integer.</p> Velocity + <p>Resolver velocity in revolutions per second.</p> VelocityScale + <p>Resolver velocityscale.</p> uri + <p>Hostname or IP address of remote libIIO deviceHelp for adi.AD2S1210.Rx/uri is inherited from superclass matlabshared.libiio.base</p> Example Usage <pre><code>%% Rx set up\nrx = adi.AD2S1210.Rx('uri','ip:analog.local');\nrx.SamplesPerFrame = 2^14;\nrx.EnabledChannels = 1;\n\n%% Run\nfor k=1:10\n    valid = false;\n    while ~valid\n        [out, valid] = rx();\n    end\nend\n\n%% Cleanup\nrelease(rx)\n</code></pre>"},{"location":"sysobjects/adi.AD4000.Rx/","title":"adi.AD4000.Rx","text":"adi.AD4000.Rx Receives data from the AD4000 ADC    The adi.AD4000.Rx System object is a signal source that can receive    data from the AD4000.     rx = adi.AD4000.Rx;    rx = adi.AD4000.Rx('uri','192.168.2.1'); AD4000 Datasheet Creation <p>The class can be instantiated in the following way with and without property name value pairs.</p> <pre><code>dev = adi.AD4000.Rx\ndev = adi.AD4000.Rx(Name, Value)\n</code></pre> Properties  Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them.  If a property is tunable, you can change its value at any time.  For more information on changing property values, see System Design in MATLAB Using System Objects. EnabledChannels + <p>Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant</p> SampleRate + <p>Baseband sampling rate in Hz, specified as a scalar in samples per second.Help for adi.AD4000.Rx/SampleRate is inherited from superclass adi.AD400x.Base</p> SamplesPerFrame + <p>Number of samples per frame, specified as an even positive integer.Help for adi.AD4000.Rx/SamplesPerFrame is inherited from superclass adi.AD400x.Base</p> VoltageOffset + <p>ADC Voltage offset.Help for adi.AD4000.Rx/VoltageOffset is inherited from superclass adi.AD400x.Base</p> VoltageScale + <p>ADC Voltage scale.Help for adi.AD4000.Rx/VoltageScale is inherited from superclass adi.AD400x.Base</p> uri + <p>Hostname or IP address of remote libIIO deviceHelp for adi.AD4000.Rx/uri is inherited from superclass matlabshared.libiio.base</p> Example Usage <pre><code>%% Rx set up\nrx = adi.AD4000.Rx('uri','ip:analog.local');\nrx.SamplesPerFrame = 2^14;\nrx.EnabledChannels = 1;\n\n%% Run\nfor k=1:10\n    valid = false;\n    while ~valid\n        [out, valid] = rx();\n    end\nend\n\n%% Cleanup\nrelease(rx)\n</code></pre>"},{"location":"sysobjects/adi.AD4001.Rx/","title":"adi.AD4001.Rx","text":"adi.AD4001.Rx Receives data from the AD4001 ADC    The adi.AD4001.Rx System object is a signal source that can receive    data from the AD4001.     rx = adi.AD4001.Rx;    rx = adi.AD4001.Rx('uri','192.168.2.1'); AD4001 Datasheet Creation <p>The class can be instantiated in the following way with and without property name value pairs.</p> <pre><code>dev = adi.AD4001.Rx\ndev = adi.AD4001.Rx(Name, Value)\n</code></pre> Properties  Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them.  If a property is tunable, you can change its value at any time.  For more information on changing property values, see System Design in MATLAB Using System Objects. EnabledChannels + <p>Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant</p> SampleRate + <p>Baseband sampling rate in Hz, specified as a scalar in samples per second.Help for adi.AD4001.Rx/SampleRate is inherited from superclass adi.AD400x.Base</p> SamplesPerFrame + <p>Number of samples per frame, specified as an even positive integer.Help for adi.AD4001.Rx/SamplesPerFrame is inherited from superclass adi.AD400x.Base</p> VoltageOffset + <p>ADC Voltage offset.Help for adi.AD4001.Rx/VoltageOffset is inherited from superclass adi.AD400x.Base</p> VoltageScale + <p>ADC Voltage scale.Help for adi.AD4001.Rx/VoltageScale is inherited from superclass adi.AD400x.Base</p> uri + <p>Hostname or IP address of remote libIIO deviceHelp for adi.AD4001.Rx/uri is inherited from superclass matlabshared.libiio.base</p> Example Usage <pre><code>%% Rx set up\nrx = adi.AD4001.Rx('uri','ip:analog.local');\nrx.SamplesPerFrame = 2^14;\nrx.EnabledChannels = 1;\n\n%% Run\nfor k=1:10\n    valid = false;\n    while ~valid\n        [out, valid] = rx();\n    end\nend\n\n%% Cleanup\nrelease(rx)\n</code></pre>"},{"location":"sysobjects/adi.AD4002.Rx/","title":"adi.AD4002.Rx","text":"adi.AD4002.Rx Receives data from the AD4002 ADC    The adi.AD4002.Rx System object is a signal source that can receive    data from the AD4002.     rx = adi.AD4002.Rx;    rx = adi.AD4002.Rx('uri','192.168.2.1'); AD4002 Datasheet Creation <p>The class can be instantiated in the following way with and without property name value pairs.</p> <pre><code>dev = adi.AD4002.Rx\ndev = adi.AD4002.Rx(Name, Value)\n</code></pre> Properties  Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them.  If a property is tunable, you can change its value at any time.  For more information on changing property values, see System Design in MATLAB Using System Objects. EnabledChannels + <p>Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant</p> SampleRate + <p>Baseband sampling rate in Hz, specified as a scalar in samples per second.Help for adi.AD4002.Rx/SampleRate is inherited from superclass adi.AD400x.Base</p> SamplesPerFrame + <p>Number of samples per frame, specified as an even positive integer.Help for adi.AD4002.Rx/SamplesPerFrame is inherited from superclass adi.AD400x.Base</p> VoltageOffset + <p>ADC Voltage offset.Help for adi.AD4002.Rx/VoltageOffset is inherited from superclass adi.AD400x.Base</p> VoltageScale + <p>ADC Voltage scale.Help for adi.AD4002.Rx/VoltageScale is inherited from superclass adi.AD400x.Base</p> uri + <p>Hostname or IP address of remote libIIO deviceHelp for adi.AD4002.Rx/uri is inherited from superclass matlabshared.libiio.base</p> Example Usage <pre><code>%% Rx set up\nrx = adi.AD4002.Rx('uri','ip:analog.local');\nrx.SamplesPerFrame = 2^14;\nrx.EnabledChannels = 1;\n\n%% Run\nfor k=1:10\n    valid = false;\n    while ~valid\n        [out, valid] = rx();\n    end\nend\n\n%% Cleanup\nrelease(rx)\n</code></pre>"},{"location":"sysobjects/adi.AD4003.Rx/","title":"adi.AD4003.Rx","text":"adi.AD4003.Rx Receives data from the AD4003 ADC    The adi.AD4003.Rx System object is a signal source that can receive    data from the AD4003.     rx = adi.AD4003.Rx;    rx = adi.AD4003.Rx('uri','192.168.2.1'); AD4003 Datasheet Creation <p>The class can be instantiated in the following way with and without property name value pairs.</p> <pre><code>dev = adi.AD4003.Rx\ndev = adi.AD4003.Rx(Name, Value)\n</code></pre> Properties  Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them.  If a property is tunable, you can change its value at any time.  For more information on changing property values, see System Design in MATLAB Using System Objects. EnabledChannels + <p>Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant</p> SampleRate + <p>Baseband sampling rate in Hz, specified as a scalar in samples per second.Help for adi.AD4003.Rx/SampleRate is inherited from superclass adi.AD400x.Base</p> SamplesPerFrame + <p>Number of samples per frame, specified as an even positive integer.Help for adi.AD4003.Rx/SamplesPerFrame is inherited from superclass adi.AD400x.Base</p> VoltageOffset + <p>ADC Voltage offset.Help for adi.AD4003.Rx/VoltageOffset is inherited from superclass adi.AD400x.Base</p> VoltageScale + <p>ADC Voltage scale.Help for adi.AD4003.Rx/VoltageScale is inherited from superclass adi.AD400x.Base</p> uri + <p>Hostname or IP address of remote libIIO deviceHelp for adi.AD4003.Rx/uri is inherited from superclass matlabshared.libiio.base</p> Example Usage <pre><code>%% Rx set up\nrx = adi.AD4003.Rx('uri','ip:analog.local');\nrx.SamplesPerFrame = 2^14;\nrx.EnabledChannels = 1;\n\n%% Run\nfor k=1:10\n    valid = false;\n    while ~valid\n        [out, valid] = rx();\n    end\nend\n\n%% Cleanup\nrelease(rx)\n</code></pre>"},{"location":"sysobjects/adi.AD4004.Rx/","title":"adi.AD4004.Rx","text":"adi.AD4004.Rx Receives data from the AD4004 ADC    The adi.AD4004.Rx System object is a signal source that can receive    data from the AD4004.     rx = adi.AD4004.Rx;    rx = adi.AD4004.Rx('uri','192.168.2.1'); AD4004 Datasheet Creation <p>The class can be instantiated in the following way with and without property name value pairs.</p> <pre><code>dev = adi.AD4004.Rx\ndev = adi.AD4004.Rx(Name, Value)\n</code></pre> Properties  Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them.  If a property is tunable, you can change its value at any time.  For more information on changing property values, see System Design in MATLAB Using System Objects. EnabledChannels + <p>Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant</p> SampleRate + <p>Baseband sampling rate in Hz, specified as a scalar in samples per second.Help for adi.AD4004.Rx/SampleRate is inherited from superclass adi.AD400x.Base</p> SamplesPerFrame + <p>Number of samples per frame, specified as an even positive integer.Help for adi.AD4004.Rx/SamplesPerFrame is inherited from superclass adi.AD400x.Base</p> VoltageOffset + <p>ADC Voltage offset.Help for adi.AD4004.Rx/VoltageOffset is inherited from superclass adi.AD400x.Base</p> VoltageScale + <p>ADC Voltage scale.Help for adi.AD4004.Rx/VoltageScale is inherited from superclass adi.AD400x.Base</p> uri + <p>Hostname or IP address of remote libIIO deviceHelp for adi.AD4004.Rx/uri is inherited from superclass matlabshared.libiio.base</p> Example Usage <pre><code>%% Rx set up\nrx = adi.AD4004.Rx('uri','ip:analog.local');\nrx.SamplesPerFrame = 2^14;\nrx.EnabledChannels = 1;\n\n%% Run\nfor k=1:10\n    valid = false;\n    while ~valid\n        [out, valid] = rx();\n    end\nend\n\n%% Cleanup\nrelease(rx)\n</code></pre>"},{"location":"sysobjects/adi.AD4005.Rx/","title":"adi.AD4005.Rx","text":"adi.AD4005.Rx Receives data from the AD4005 ADC    The adi.AD4005.Rx System object is a signal source that can receive    data from the AD4005.     rx = adi.AD4005.Rx;    rx = adi.AD4005.Rx('uri','192.168.2.1'); AD4005 Datasheet Creation <p>The class can be instantiated in the following way with and without property name value pairs.</p> <pre><code>dev = adi.AD4005.Rx\ndev = adi.AD4005.Rx(Name, Value)\n</code></pre> Properties  Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them.  If a property is tunable, you can change its value at any time.  For more information on changing property values, see System Design in MATLAB Using System Objects. EnabledChannels + <p>Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant</p> SampleRate + <p>Baseband sampling rate in Hz, specified as a scalar in samples per second.Help for adi.AD4005.Rx/SampleRate is inherited from superclass adi.AD400x.Base</p> SamplesPerFrame + <p>Number of samples per frame, specified as an even positive integer.Help for adi.AD4005.Rx/SamplesPerFrame is inherited from superclass adi.AD400x.Base</p> VoltageOffset + <p>ADC Voltage offset.Help for adi.AD4005.Rx/VoltageOffset is inherited from superclass adi.AD400x.Base</p> VoltageScale + <p>ADC Voltage scale.Help for adi.AD4005.Rx/VoltageScale is inherited from superclass adi.AD400x.Base</p> uri + <p>Hostname or IP address of remote libIIO deviceHelp for adi.AD4005.Rx/uri is inherited from superclass matlabshared.libiio.base</p> Example Usage <pre><code>%% Rx set up\nrx = adi.AD4005.Rx('uri','ip:analog.local');\nrx.SamplesPerFrame = 2^14;\nrx.EnabledChannels = 1;\n\n%% Run\nfor k=1:10\n    valid = false;\n    while ~valid\n        [out, valid] = rx();\n    end\nend\n\n%% Cleanup\nrelease(rx)\n</code></pre>"},{"location":"sysobjects/adi.AD4006.Rx/","title":"adi.AD4006.Rx","text":"adi.AD4006.Rx Receives data from the AD4006 ADC    The adi.AD4006.Rx System object is a signal source that can receive    data from the AD4006.     rx = adi.AD4006.Rx;    rx = adi.AD4006.Rx('uri','192.168.2.1'); AD4006 Datasheet Creation <p>The class can be instantiated in the following way with and without property name value pairs.</p> <pre><code>dev = adi.AD4006.Rx\ndev = adi.AD4006.Rx(Name, Value)\n</code></pre> Properties  Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them.  If a property is tunable, you can change its value at any time.  For more information on changing property values, see System Design in MATLAB Using System Objects. EnabledChannels + <p>Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant</p> SampleRate + <p>Baseband sampling rate in Hz, specified as a scalar in samples per second.Help for adi.AD4006.Rx/SampleRate is inherited from superclass adi.AD400x.Base</p> SamplesPerFrame + <p>Number of samples per frame, specified as an even positive integer.Help for adi.AD4006.Rx/SamplesPerFrame is inherited from superclass adi.AD400x.Base</p> VoltageOffset + <p>ADC Voltage offset.Help for adi.AD4006.Rx/VoltageOffset is inherited from superclass adi.AD400x.Base</p> VoltageScale + <p>ADC Voltage scale.Help for adi.AD4006.Rx/VoltageScale is inherited from superclass adi.AD400x.Base</p> uri + <p>Hostname or IP address of remote libIIO deviceHelp for adi.AD4006.Rx/uri is inherited from superclass matlabshared.libiio.base</p> Example Usage <pre><code>%% Rx set up\nrx = adi.AD4006.Rx('uri','ip:analog.local');\nrx.SamplesPerFrame = 2^14;\nrx.EnabledChannels = 1;\n\n%% Run\nfor k=1:10\n    valid = false;\n    while ~valid\n        [out, valid] = rx();\n    end\nend\n\n%% Cleanup\nrelease(rx)\n</code></pre>"},{"location":"sysobjects/adi.AD4007.Rx/","title":"adi.AD4007.Rx","text":"adi.AD4007.Rx Receives data from the AD4007 ADC    The adi.AD4007.Rx System object is a signal source that can receive    data from the AD4007.     rx = adi.AD4007.Rx;    rx = adi.AD4007.Rx('uri','192.168.2.1'); AD4007 Datasheet Creation <p>The class can be instantiated in the following way with and without property name value pairs.</p> <pre><code>dev = adi.AD4007.Rx\ndev = adi.AD4007.Rx(Name, Value)\n</code></pre> Properties  Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them.  If a property is tunable, you can change its value at any time.  For more information on changing property values, see System Design in MATLAB Using System Objects. EnabledChannels + <p>Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant</p> SampleRate + <p>Baseband sampling rate in Hz, specified as a scalar in samples per second.Help for adi.AD4007.Rx/SampleRate is inherited from superclass adi.AD400x.Base</p> SamplesPerFrame + <p>Number of samples per frame, specified as an even positive integer.Help for adi.AD4007.Rx/SamplesPerFrame is inherited from superclass adi.AD400x.Base</p> VoltageOffset + <p>ADC Voltage offset.Help for adi.AD4007.Rx/VoltageOffset is inherited from superclass adi.AD400x.Base</p> VoltageScale + <p>ADC Voltage scale.Help for adi.AD4007.Rx/VoltageScale is inherited from superclass adi.AD400x.Base</p> uri + <p>Hostname or IP address of remote libIIO deviceHelp for adi.AD4007.Rx/uri is inherited from superclass matlabshared.libiio.base</p> Example Usage <pre><code>%% Rx set up\nrx = adi.AD4007.Rx('uri','ip:analog.local');\nrx.SamplesPerFrame = 2^14;\nrx.EnabledChannels = 1;\n\n%% Run\nfor k=1:10\n    valid = false;\n    while ~valid\n        [out, valid] = rx();\n    end\nend\n\n%% Cleanup\nrelease(rx)\n</code></pre>"},{"location":"sysobjects/adi.AD4008.Rx/","title":"adi.AD4008.Rx","text":"adi.AD4008.Rx Receives data from the AD4008 ADC    The adi.AD4008.Rx System object is a signal source that can receive    data from the AD4008.     rx = adi.AD4008.Rx;    rx = adi.AD4008.Rx('uri','192.168.2.1'); AD4008 Datasheet Creation <p>The class can be instantiated in the following way with and without property name value pairs.</p> <pre><code>dev = adi.AD4008.Rx\ndev = adi.AD4008.Rx(Name, Value)\n</code></pre> Properties  Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them.  If a property is tunable, you can change its value at any time.  For more information on changing property values, see System Design in MATLAB Using System Objects. EnabledChannels + <p>Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant</p> SampleRate + <p>Baseband sampling rate in Hz, specified as a scalar in samples per second.Help for adi.AD4008.Rx/SampleRate is inherited from superclass adi.AD400x.Base</p> SamplesPerFrame + <p>Number of samples per frame, specified as an even positive integer.Help for adi.AD4008.Rx/SamplesPerFrame is inherited from superclass adi.AD400x.Base</p> VoltageOffset + <p>ADC Voltage offset.Help for adi.AD4008.Rx/VoltageOffset is inherited from superclass adi.AD400x.Base</p> VoltageScale + <p>ADC Voltage scale.Help for adi.AD4008.Rx/VoltageScale is inherited from superclass adi.AD400x.Base</p> uri + <p>Hostname or IP address of remote libIIO deviceHelp for adi.AD4008.Rx/uri is inherited from superclass matlabshared.libiio.base</p> Example Usage <pre><code>%% Rx set up\nrx = adi.AD4008.Rx('uri','ip:analog.local');\nrx.SamplesPerFrame = 2^14;\nrx.EnabledChannels = 1;\n\n%% Run\nfor k=1:10\n    valid = false;\n    while ~valid\n        [out, valid] = rx();\n    end\nend\n\n%% Cleanup\nrelease(rx)\n</code></pre>"},{"location":"sysobjects/adi.AD4010.Rx/","title":"adi.AD4010.Rx","text":"adi.AD4010.Rx Receives data from the AD4010 ADC    The adi.AD4010.Rx System object is a signal source that can receive    data from the AD4010.     rx = adi.AD4010.Rx;    rx = adi.AD4010.Rx('uri','192.168.2.1'); AD4010 Datasheet Creation <p>The class can be instantiated in the following way with and without property name value pairs.</p> <pre><code>dev = adi.AD4010.Rx\ndev = adi.AD4010.Rx(Name, Value)\n</code></pre> Properties  Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them.  If a property is tunable, you can change its value at any time.  For more information on changing property values, see System Design in MATLAB Using System Objects. EnabledChannels + <p>Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant</p> SampleRate + <p>Baseband sampling rate in Hz, specified as a scalar in samples per second.Help for adi.AD4010.Rx/SampleRate is inherited from superclass adi.AD400x.Base</p> SamplesPerFrame + <p>Number of samples per frame, specified as an even positive integer.Help for adi.AD4010.Rx/SamplesPerFrame is inherited from superclass adi.AD400x.Base</p> VoltageOffset + <p>ADC Voltage offset.Help for adi.AD4010.Rx/VoltageOffset is inherited from superclass adi.AD400x.Base</p> VoltageScale + <p>ADC Voltage scale.Help for adi.AD4010.Rx/VoltageScale is inherited from superclass adi.AD400x.Base</p> uri + <p>Hostname or IP address of remote libIIO deviceHelp for adi.AD4010.Rx/uri is inherited from superclass matlabshared.libiio.base</p> Example Usage <pre><code>%% Rx set up\nrx = adi.AD4010.Rx('uri','ip:analog.local');\nrx.SamplesPerFrame = 2^14;\nrx.EnabledChannels = 1;\n\n%% Run\nfor k=1:10\n    valid = false;\n    while ~valid\n        [out, valid] = rx();\n    end\nend\n\n%% Cleanup\nrelease(rx)\n</code></pre>"},{"location":"sysobjects/adi.AD4011.Rx/","title":"adi.AD4011.Rx","text":"adi.AD4011.Rx Receives data from the AD4011 ADC    The adi.AD4011.Rx System object is a signal source that can receive    data from the AD4011.     rx = adi.AD4011.Rx;    rx = adi.AD4011.Rx('uri','192.168.2.1'); AD4011 Datasheet Creation <p>The class can be instantiated in the following way with and without property name value pairs.</p> <pre><code>dev = adi.AD4011.Rx\ndev = adi.AD4011.Rx(Name, Value)\n</code></pre> Properties  Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them.  If a property is tunable, you can change its value at any time.  For more information on changing property values, see System Design in MATLAB Using System Objects. EnabledChannels + <p>Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant</p> SampleRate + <p>Baseband sampling rate in Hz, specified as a scalar in samples per second.Help for adi.AD4011.Rx/SampleRate is inherited from superclass adi.AD400x.Base</p> SamplesPerFrame + <p>Number of samples per frame, specified as an even positive integer.Help for adi.AD4011.Rx/SamplesPerFrame is inherited from superclass adi.AD400x.Base</p> VoltageOffset + <p>ADC Voltage offset.Help for adi.AD4011.Rx/VoltageOffset is inherited from superclass adi.AD400x.Base</p> VoltageScale + <p>ADC Voltage scale.Help for adi.AD4011.Rx/VoltageScale is inherited from superclass adi.AD400x.Base</p> uri + <p>Hostname or IP address of remote libIIO deviceHelp for adi.AD4011.Rx/uri is inherited from superclass matlabshared.libiio.base</p> Example Usage <pre><code>%% Rx set up\nrx = adi.AD4011.Rx('uri','ip:analog.local');\nrx.SamplesPerFrame = 2^14;\nrx.EnabledChannels = 1;\n\n%% Run\nfor k=1:10\n    valid = false;\n    while ~valid\n        [out, valid] = rx();\n    end\nend\n\n%% Cleanup\nrelease(rx)\n</code></pre>"},{"location":"sysobjects/adi.AD4020.Rx/","title":"adi.AD4020.Rx","text":"adi.AD4020.Rx Receives data from the AD4020 ADC    The adi.AD4020.Rx System object is a signal source that can receive    data from the AD4020.     rx = adi.AD4020.Rx;    rx = adi.AD4020.Rx('uri','192.168.2.1'); AD4020 Datasheet Creation <p>The class can be instantiated in the following way with and without property name value pairs.</p> <pre><code>dev = adi.AD4020.Rx\ndev = adi.AD4020.Rx(Name, Value)\n</code></pre> Properties  Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them.  If a property is tunable, you can change its value at any time.  For more information on changing property values, see System Design in MATLAB Using System Objects. EnabledChannels + <p>Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant</p> SampleRate + <p>Baseband sampling rate in Hz, specified as a scalar in samples per second.Help for adi.AD4020.Rx/SampleRate is inherited from superclass adi.AD400x.Base</p> SamplesPerFrame + <p>Number of samples per frame, specified as an even positive integer.Help for adi.AD4020.Rx/SamplesPerFrame is inherited from superclass adi.AD400x.Base</p> VoltageOffset + <p>ADC Voltage offset.Help for adi.AD4020.Rx/VoltageOffset is inherited from superclass adi.AD400x.Base</p> VoltageScale + <p>ADC Voltage scale.Help for adi.AD4020.Rx/VoltageScale is inherited from superclass adi.AD400x.Base</p> uri + <p>Hostname or IP address of remote libIIO deviceHelp for adi.AD4020.Rx/uri is inherited from superclass matlabshared.libiio.base</p> Example Usage <pre><code>%% Rx set up\nrx = adi.AD4020.Rx('uri','ip:analog.local');\nrx.SamplesPerFrame = 2^14;\nrx.EnabledChannels = 1;\n\n%% Run\nfor k=1:10\n    valid = false;\n    while ~valid\n        [out, valid] = rx();\n    end\nend\n\n%% Cleanup\nrelease(rx)\n</code></pre>"},{"location":"sysobjects/adi.AD4021.Rx/","title":"adi.AD4021.Rx","text":"adi.AD4021.Rx Receives data from the AD4021 ADC    The adi.AD4021.Rx System object is a signal source that can receive    data from the AD4021.     rx = adi.AD4021.Rx;    rx = adi.AD4021.Rx('uri','192.168.2.1'); AD4021 Datasheet Creation <p>The class can be instantiated in the following way with and without property name value pairs.</p> <pre><code>dev = adi.AD4021.Rx\ndev = adi.AD4021.Rx(Name, Value)\n</code></pre> Properties  Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them.  If a property is tunable, you can change its value at any time.  For more information on changing property values, see System Design in MATLAB Using System Objects. EnabledChannels + <p>Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant</p> SampleRate + <p>Baseband sampling rate in Hz, specified as a scalar in samples per second.Help for adi.AD4021.Rx/SampleRate is inherited from superclass adi.AD400x.Base</p> SamplesPerFrame + <p>Number of samples per frame, specified as an even positive integer.Help for adi.AD4021.Rx/SamplesPerFrame is inherited from superclass adi.AD400x.Base</p> VoltageOffset + <p>ADC Voltage offset.Help for adi.AD4021.Rx/VoltageOffset is inherited from superclass adi.AD400x.Base</p> VoltageScale + <p>ADC Voltage scale.Help for adi.AD4021.Rx/VoltageScale is inherited from superclass adi.AD400x.Base</p> uri + <p>Hostname or IP address of remote libIIO deviceHelp for adi.AD4021.Rx/uri is inherited from superclass matlabshared.libiio.base</p> Example Usage <pre><code>%% Rx set up\nrx = adi.AD4021.Rx('uri','ip:analog.local');\nrx.SamplesPerFrame = 2^14;\nrx.EnabledChannels = 1;\n\n%% Run\nfor k=1:10\n    valid = false;\n    while ~valid\n        [out, valid] = rx();\n    end\nend\n\n%% Cleanup\nrelease(rx)\n</code></pre>"},{"location":"sysobjects/adi.AD4022.Rx/","title":"adi.AD4022.Rx","text":"adi.AD4022.Rx Receives data from the AD4022 ADC    The adi.AD4022.Rx System object is a signal source that can receive    data from the AD4022.     rx = adi.AD4022.Rx;    rx = adi.AD4022.Rx('uri','192.168.2.1'); AD4022 Datasheet Creation <p>The class can be instantiated in the following way with and without property name value pairs.</p> <pre><code>dev = adi.AD4022.Rx\ndev = adi.AD4022.Rx(Name, Value)\n</code></pre> Properties  Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them.  If a property is tunable, you can change its value at any time.  For more information on changing property values, see System Design in MATLAB Using System Objects. EnabledChannels + <p>Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant</p> SampleRate + <p>Baseband sampling rate in Hz, specified as a scalar in samples per second.Help for adi.AD4022.Rx/SampleRate is inherited from superclass adi.AD400x.Base</p> SamplesPerFrame + <p>Number of samples per frame, specified as an even positive integer.Help for adi.AD4022.Rx/SamplesPerFrame is inherited from superclass adi.AD400x.Base</p> VoltageOffset + <p>ADC Voltage offset.Help for adi.AD4022.Rx/VoltageOffset is inherited from superclass adi.AD400x.Base</p> VoltageScale + <p>ADC Voltage scale.Help for adi.AD4022.Rx/VoltageScale is inherited from superclass adi.AD400x.Base</p> uri + <p>Hostname or IP address of remote libIIO deviceHelp for adi.AD4022.Rx/uri is inherited from superclass matlabshared.libiio.base</p> Example Usage <pre><code>%% Rx set up\nrx = adi.AD4022.Rx('uri','ip:analog.local');\nrx.SamplesPerFrame = 2^14;\nrx.EnabledChannels = 1;\n\n%% Run\nfor k=1:10\n    valid = false;\n    while ~valid\n        [out, valid] = rx();\n    end\nend\n\n%% Cleanup\nrelease(rx)\n</code></pre>"},{"location":"sysobjects/adi.AD4030.Rx/","title":"adi.AD4030.Rx","text":"adi.AD4030.Rx Receives data from the AD4030-24 ADC    The adi.AD4030.Rx System object is a signal source that can receive    data from the AD4030-24.     rx = adi.AD4030.Rx;    rx = adi.AD4030.Rx('uri','192.168.2.1'); AD4030-24 Datasheet Creation <p>The class can be instantiated in the following way with and without property name value pairs.</p> <pre><code>dev = adi.AD4030.Rx\ndev = adi.AD4030.Rx(Name, Value)\n</code></pre> Properties  Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them.  If a property is tunable, you can change its value at any time.  For more information on changing property values, see System Design in MATLAB Using System Objects. EnabledChannels + <p>Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant</p> SampleAveragingLength + <p>Block length of samples to be averaged. Applied in the Averaging Mode register only when OUT_DATA_MD is set to 30-bit averaged differential modeHelp for adi.AD4030.Rx/SampleAveragingLength is inherited from superclass adi.AD463x.Base</p> SampleRate + <p>Baseband sampling rate in Hz, specified as a scalar in samples per second.Help for adi.AD4030.Rx/SampleRate is inherited from superclass adi.AD463x.Base</p> SamplesPerFrame + <p>Number of samples per frame, specified as an even positive integer.Help for adi.AD4030.Rx/SamplesPerFrame is inherited from superclass adi.AD463x.Base</p> uri + <p>Hostname or IP address of remote libIIO deviceHelp for adi.AD4030.Rx/uri is inherited from superclass matlabshared.libiio.base</p> Example Usage <pre><code>%% Rx set up\nrx = adi.AD4030.Rx('uri','ip:analog.local');\nrx.SamplesPerFrame = 2^14;\nrx.EnabledChannels = 1;\n\n%% Run\nfor k=1:10\n    valid = false;\n    while ~valid\n        [out, valid] = rx();\n    end\nend\n\n%% Cleanup\nrelease(rx)\n</code></pre>"},{"location":"sysobjects/adi.AD4630_16.Rx/","title":"adi.AD4630_16.Rx","text":"adi.AD4630_16.Rx Receive data from the AD4630-16 ADC    The adi.AD4630_16.Rx System object is a signal source that can receive    data from the AD4630-16.     rx = adi.AD4630_16.Rx;    rx = adi.AD4630_16.Rx('uri','192.168.2.1'); AD4630-16 Datasheet Creation <p>The class can be instantiated in the following way with and without property name value pairs.</p> <pre><code>dev = adi.AD4630_16.Rx\ndev = adi.AD4630_16.Rx(Name, Value)\n</code></pre> Properties  Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them.  If a property is tunable, you can change its value at any time.  For more information on changing property values, see System Design in MATLAB Using System Objects. EnabledChannels + <p>Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant</p> SampleAveragingLength + <p>Block length of samples to be averaged. Applied in the Averaging Mode register only when OUT_DATA_MD is set to 30-bit averaged differential modeHelp for adi.AD4630_16.Rx/SampleAveragingLength is inherited from superclass adi.AD463x.Base</p> SampleRate + <p>Baseband sampling rate in Hz, specified as a scalar in samples per second.Help for adi.AD4630_16.Rx/SampleRate is inherited from superclass adi.AD463x.Base</p> SamplesPerFrame + <p>Number of samples per frame, specified as an even positive integer.Help for adi.AD4630_16.Rx/SamplesPerFrame is inherited from superclass adi.AD463x.Base</p> uri + <p>Hostname or IP address of remote libIIO deviceHelp for adi.AD4630_16.Rx/uri is inherited from superclass matlabshared.libiio.base</p> Example Usage <pre><code>%% Rx set up\nrx = adi.AD4630_16.Rx('uri','ip:analog.local');\nrx.SamplesPerFrame = 2^14;\nrx.EnabledChannels = 1;\n\n%% Run\nfor k=1:10\n    valid = false;\n    while ~valid\n        [out, valid] = rx();\n    end\nend\n\n%% Cleanup\nrelease(rx)\n</code></pre>"},{"location":"sysobjects/adi.AD4630_24.Rx/","title":"adi.AD4630_24.Rx","text":"adi.AD4630_24.Rx Receive data from the AD4630-24 ADC    The adi.AD4630_24.Rx System object is a signal source that can receive    data from the AD4630-24.     rx = adi.AD4630_24.Rx;    rx = adi.AD4630_24.Rx('uri','192.168.2.1'); AD4630-24 Datasheet Creation <p>The class can be instantiated in the following way with and without property name value pairs.</p> <pre><code>dev = adi.AD4630_24.Rx\ndev = adi.AD4630_24.Rx(Name, Value)\n</code></pre> Properties  Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them.  If a property is tunable, you can change its value at any time.  For more information on changing property values, see System Design in MATLAB Using System Objects. EnabledChannels + <p>Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant</p> SampleAveragingLength + <p>Block length of samples to be averaged. Applied in the Averaging Mode register only when OUT_DATA_MD is set to 30-bit averaged differential modeHelp for adi.AD4630_24.Rx/SampleAveragingLength is inherited from superclass adi.AD463x.Base</p> SampleRate + <p>Baseband sampling rate in Hz, specified as a scalar in samples per second.Help for adi.AD4630_24.Rx/SampleRate is inherited from superclass adi.AD463x.Base</p> SamplesPerFrame + <p>Number of samples per frame, specified as an even positive integer.Help for adi.AD4630_24.Rx/SamplesPerFrame is inherited from superclass adi.AD463x.Base</p> uri + <p>Hostname or IP address of remote libIIO deviceHelp for adi.AD4630_24.Rx/uri is inherited from superclass matlabshared.libiio.base</p> Example Usage <pre><code>%% Rx set up\nrx = adi.AD4630_24.Rx('uri','ip:analog.local');\nrx.SamplesPerFrame = 2^14;\nrx.EnabledChannels = 1;\n\n%% Run\nfor k=1:10\n    valid = false;\n    while ~valid\n        [out, valid] = rx();\n    end\nend\n\n%% Cleanup\nrelease(rx)\n</code></pre>"},{"location":"sysobjects/adi.AD4858.Rx/","title":"adi.AD4858.Rx","text":"adi.AD4858.Rx Receives data from the AD4858 ADC    The adi.AD4858.Rx System object is a signal source that can receive    data from the AD4858.     rx = adi.AD4858.Rx;    rx = adi.AD4858.Rx('uri','192.168.2.1'); AD4858 Datasheet Creation <p>The class can be instantiated in the following way with and without property name value pairs.</p> <pre><code>dev = adi.AD4858.Rx\ndev = adi.AD4858.Rx(Name, Value)\n</code></pre> Properties  Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them.  If a property is tunable, you can change its value at any time.  For more information on changing property values, see System Design in MATLAB Using System Objects. EnabledChannels + <p>Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant</p> SampleRate + <p>Baseband sampling rate in Hz, specified as a scalar in samples per second.</p> SamplesPerFrame + <p>Number of samples per frame, specified as an even positive integer.</p> uri + <p>Hostname or IP address of remote libIIO deviceHelp for adi.AD4858.Rx/uri is inherited from superclass matlabshared.libiio.base</p> Example Usage <pre><code>%% Rx set up\nrx = adi.AD4858.Rx('uri','ip:analog.local');\nrx.SamplesPerFrame = 2^14;\nrx.EnabledChannels = 1;\n\n%% Run\nfor k=1:10\n    valid = false;\n    while ~valid\n        [out, valid] = rx();\n    end\nend\n\n%% Cleanup\nrelease(rx)\n</code></pre>"},{"location":"sysobjects/adi.AD5760.Tx/","title":"adi.AD5760.Tx","text":"adi.AD5760.Tx Transmits data to the AD5760 DAC    The adi.AD5760.Tx System object is a signal sink that can transmit    data to the AD5760.     tx = adi.AD5760.Tx;    tx = adi.AD5760.Tx('uri','ip:192.168.2.1'); AD5760 Datasheet Creation <p>The class can be instantiated in the following way with and without property name value pairs.</p> <pre><code>dev = adi.AD5760.Tx\ndev = adi.AD5760.Tx(Name, Value)\n</code></pre> Properties  Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them.  If a property is tunable, you can change its value at any time.  For more information on changing property values, see System Design in MATLAB Using System Objects. CodeSelect + <p>Set to 2s_complement/offset_binaryHelp for adi.AD5760.Tx/CodeSelect is inherited from superclass adi.AD579x.Base</p> DDSFrequencies + <p>Frequencies values in Hz of the DDS tone generators. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N &lt; this upper limit, other DDSs are not set.Help for adi.AD5760.Tx/DDSFrequencies is inherited from superclass adi.common.DDS</p> DDSPhases + <p>Phases of DDS tones in range [0,360000]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N &lt; this upper limit, other DDSs are not set.Help for adi.AD5760.Tx/DDSPhases is inherited from superclass adi.common.DDS</p> DDSScales + <p>Scale of DDS tones in range [0,1]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N &lt; this upper limit, other DDSs are not set.Help for adi.AD5760.Tx/DDSScales is inherited from superclass adi.common.DDS</p> DataSource + <p>Data source, specified as one of the following: 'DMA' \u2014 Specify the host as the source of the data. 'DDS' \u2014 Specify the DDS on the radio hardware as the source of the data. In this case, each channel has two additive tones.Help for adi.AD5760.Tx/DataSource is inherited from superclass adi.common.DDS</p> EnableCyclicBuffers + <p>Enable Cyclic Buffers, configures transmit buffers to be cyclic, which makes them continuously repeatHelp for adi.AD5760.Tx/EnableCyclicBuffers is inherited from superclass adi.common.DDS</p> EnabledChannels + <p>Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant</p> PowerDown + <p>Set to true/false to power-up/power-down the device channelsHelp for adi.AD5760.Tx/PowerDown is inherited from superclass adi.AD579x.Base</p> Raw + <p>Help for adi.AD5760.Tx/Raw is inherited from superclass adi.AD579x.Base</p> SampleRate + <p>Baseband sampling rate in Hz, specified as a scalar in samples per second. Help for adi.AD5760.Tx/SampleRate is inherited from superclass adi.AD579x.Base</p> SamplesPerFrame + <p>Number of samples per frame, specified as an even positive integer. Help for adi.AD5760.Tx/SamplesPerFrame is inherited from superclass adi.AD579x.Base</p> uri + <p>Hostname or IP address of remote libIIO deviceHelp for adi.AD5760.Tx/uri is inherited from superclass matlabshared.libiio.base</p> Example Usage <pre><code>%% Configure device\ntx = adi.AD5760.Tx;\ntx.uri = \"ip:analog.local\";\ntx.DataSource = 'DMA';\ntx.EnableCyclicBuffers = true;\ntx.EnabledChannels = 1;\n\n%% Generate tone\namplitude = 2^15; frequency = 0.12e6;\nswv1 = dsp.SineWave(amplitude, frequency);\nswv1.SamplesPerFrame = 2^14;\n\nswv1.SampleRate = tx.SamplingRate;\ny = swv1();\n\n%% Send\ntx(y);\n</code></pre>"},{"location":"sysobjects/adi.AD5780.Tx/","title":"adi.AD5780.Tx","text":"adi.AD5780.Tx Transmits data to the AD5780 DAC    The adi.AD5780.Tx System object is a signal sink that can transmit    data to the AD5780.     tx = adi.AD5780.Tx;    tx = adi.AD5780.Tx('uri','ip:192.168.2.1'); AD5780 Datasheet Creation <p>The class can be instantiated in the following way with and without property name value pairs.</p> <pre><code>dev = adi.AD5780.Tx\ndev = adi.AD5780.Tx(Name, Value)\n</code></pre> Properties  Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them.  If a property is tunable, you can change its value at any time.  For more information on changing property values, see System Design in MATLAB Using System Objects. CodeSelect + <p>Set to 2s_complement/offset_binaryHelp for adi.AD5780.Tx/CodeSelect is inherited from superclass adi.AD579x.Base</p> DDSFrequencies + <p>Frequencies values in Hz of the DDS tone generators. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N &lt; this upper limit, other DDSs are not set.Help for adi.AD5780.Tx/DDSFrequencies is inherited from superclass adi.common.DDS</p> DDSPhases + <p>Phases of DDS tones in range [0,360000]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N &lt; this upper limit, other DDSs are not set.Help for adi.AD5780.Tx/DDSPhases is inherited from superclass adi.common.DDS</p> DDSScales + <p>Scale of DDS tones in range [0,1]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N &lt; this upper limit, other DDSs are not set.Help for adi.AD5780.Tx/DDSScales is inherited from superclass adi.common.DDS</p> DataSource + <p>Data source, specified as one of the following: 'DMA' \u2014 Specify the host as the source of the data. 'DDS' \u2014 Specify the DDS on the radio hardware as the source of the data. In this case, each channel has two additive tones.Help for adi.AD5780.Tx/DataSource is inherited from superclass adi.common.DDS</p> EnableCyclicBuffers + <p>Enable Cyclic Buffers, configures transmit buffers to be cyclic, which makes them continuously repeatHelp for adi.AD5780.Tx/EnableCyclicBuffers is inherited from superclass adi.common.DDS</p> EnabledChannels + <p>Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant</p> PowerDown + <p>Set to true/false to power-up/power-down the device channelsHelp for adi.AD5780.Tx/PowerDown is inherited from superclass adi.AD579x.Base</p> Raw + <p>Help for adi.AD5780.Tx/Raw is inherited from superclass adi.AD579x.Base</p> SampleRate + <p>Baseband sampling rate in Hz, specified as a scalar in samples per second. Help for adi.AD5780.Tx/SampleRate is inherited from superclass adi.AD579x.Base</p> SamplesPerFrame + <p>Number of samples per frame, specified as an even positive integer. Help for adi.AD5780.Tx/SamplesPerFrame is inherited from superclass adi.AD579x.Base</p> uri + <p>Hostname or IP address of remote libIIO deviceHelp for adi.AD5780.Tx/uri is inherited from superclass matlabshared.libiio.base</p> Example Usage <pre><code>%% Configure device\ntx = adi.AD5780.Tx;\ntx.uri = \"ip:analog.local\";\ntx.DataSource = 'DMA';\ntx.EnableCyclicBuffers = true;\ntx.EnabledChannels = 1;\n\n%% Generate tone\namplitude = 2^15; frequency = 0.12e6;\nswv1 = dsp.SineWave(amplitude, frequency);\nswv1.SamplesPerFrame = 2^14;\n\nswv1.SampleRate = tx.SamplingRate;\ny = swv1();\n\n%% Send\ntx(y);\n</code></pre>"},{"location":"sysobjects/adi.AD5781.Tx/","title":"adi.AD5781.Tx","text":"adi.AD5781.Tx Transmits data to the AD5781 DAC    The adi.AD5781.Tx System object is a signal sink that can transmit    data to the AD5781.     tx = adi.AD5781.Tx;    tx = adi.AD5781.Tx('uri','ip:192.168.2.1'); AD5781 Datasheet Creation <p>The class can be instantiated in the following way with and without property name value pairs.</p> <pre><code>dev = adi.AD5781.Tx\ndev = adi.AD5781.Tx(Name, Value)\n</code></pre> Properties  Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them.  If a property is tunable, you can change its value at any time.  For more information on changing property values, see System Design in MATLAB Using System Objects. CodeSelect + <p>Set to 2s_complement/offset_binaryHelp for adi.AD5781.Tx/CodeSelect is inherited from superclass adi.AD579x.Base</p> DDSFrequencies + <p>Frequencies values in Hz of the DDS tone generators. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N &lt; this upper limit, other DDSs are not set.Help for adi.AD5781.Tx/DDSFrequencies is inherited from superclass adi.common.DDS</p> DDSPhases + <p>Phases of DDS tones in range [0,360000]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N &lt; this upper limit, other DDSs are not set.Help for adi.AD5781.Tx/DDSPhases is inherited from superclass adi.common.DDS</p> DDSScales + <p>Scale of DDS tones in range [0,1]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N &lt; this upper limit, other DDSs are not set.Help for adi.AD5781.Tx/DDSScales is inherited from superclass adi.common.DDS</p> DataSource + <p>Data source, specified as one of the following: 'DMA' \u2014 Specify the host as the source of the data. 'DDS' \u2014 Specify the DDS on the radio hardware as the source of the data. In this case, each channel has two additive tones.Help for adi.AD5781.Tx/DataSource is inherited from superclass adi.common.DDS</p> EnableCyclicBuffers + <p>Enable Cyclic Buffers, configures transmit buffers to be cyclic, which makes them continuously repeatHelp for adi.AD5781.Tx/EnableCyclicBuffers is inherited from superclass adi.common.DDS</p> EnabledChannels + <p>Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant</p> PowerDown + <p>Set to true/false to power-up/power-down the device channelsHelp for adi.AD5781.Tx/PowerDown is inherited from superclass adi.AD579x.Base</p> Raw + <p>Help for adi.AD5781.Tx/Raw is inherited from superclass adi.AD579x.Base</p> SampleRate + <p>Baseband sampling rate in Hz, specified as a scalar in samples per second. Help for adi.AD5781.Tx/SampleRate is inherited from superclass adi.AD579x.Base</p> SamplesPerFrame + <p>Number of samples per frame, specified as an even positive integer. Help for adi.AD5781.Tx/SamplesPerFrame is inherited from superclass adi.AD579x.Base</p> uri + <p>Hostname or IP address of remote libIIO deviceHelp for adi.AD5781.Tx/uri is inherited from superclass matlabshared.libiio.base</p> Example Usage <pre><code>%% Configure device\ntx = adi.AD5781.Tx;\ntx.uri = \"ip:analog.local\";\ntx.DataSource = 'DMA';\ntx.EnableCyclicBuffers = true;\ntx.EnabledChannels = 1;\n\n%% Generate tone\namplitude = 2^15; frequency = 0.12e6;\nswv1 = dsp.SineWave(amplitude, frequency);\nswv1.SamplesPerFrame = 2^14;\n\nswv1.SampleRate = tx.SamplingRate;\ny = swv1();\n\n%% Send\ntx(y);\n</code></pre>"},{"location":"sysobjects/adi.AD5790.Tx/","title":"adi.AD5790.Tx","text":"adi.AD5790.Tx Transmits data to the AD5790 DAC    The adi.AD5790.Tx System object is a signal sink that can transmit    data to the AD5790.     tx = adi.AD5790.Tx;    tx = adi.AD5790.Tx('uri','ip:192.168.2.1'); AD5790 Datasheet Creation <p>The class can be instantiated in the following way with and without property name value pairs.</p> <pre><code>dev = adi.AD5790.Tx\ndev = adi.AD5790.Tx(Name, Value)\n</code></pre> Properties  Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them.  If a property is tunable, you can change its value at any time.  For more information on changing property values, see System Design in MATLAB Using System Objects. CodeSelect + <p>Set to 2s_complement/offset_binaryHelp for adi.AD5790.Tx/CodeSelect is inherited from superclass adi.AD579x.Base</p> DDSFrequencies + <p>Frequencies values in Hz of the DDS tone generators. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N &lt; this upper limit, other DDSs are not set.Help for adi.AD5790.Tx/DDSFrequencies is inherited from superclass adi.common.DDS</p> DDSPhases + <p>Phases of DDS tones in range [0,360000]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N &lt; this upper limit, other DDSs are not set.Help for adi.AD5790.Tx/DDSPhases is inherited from superclass adi.common.DDS</p> DDSScales + <p>Scale of DDS tones in range [0,1]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N &lt; this upper limit, other DDSs are not set.Help for adi.AD5790.Tx/DDSScales is inherited from superclass adi.common.DDS</p> DataSource + <p>Data source, specified as one of the following: 'DMA' \u2014 Specify the host as the source of the data. 'DDS' \u2014 Specify the DDS on the radio hardware as the source of the data. In this case, each channel has two additive tones.Help for adi.AD5790.Tx/DataSource is inherited from superclass adi.common.DDS</p> EnableCyclicBuffers + <p>Enable Cyclic Buffers, configures transmit buffers to be cyclic, which makes them continuously repeatHelp for adi.AD5790.Tx/EnableCyclicBuffers is inherited from superclass adi.common.DDS</p> EnabledChannels + <p>Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant</p> PowerDown + <p>Set to true/false to power-up/power-down the device channelsHelp for adi.AD5790.Tx/PowerDown is inherited from superclass adi.AD579x.Base</p> Raw + <p>Help for adi.AD5790.Tx/Raw is inherited from superclass adi.AD579x.Base</p> SampleRate + <p>Baseband sampling rate in Hz, specified as a scalar in samples per second. Help for adi.AD5790.Tx/SampleRate is inherited from superclass adi.AD579x.Base</p> SamplesPerFrame + <p>Number of samples per frame, specified as an even positive integer. Help for adi.AD5790.Tx/SamplesPerFrame is inherited from superclass adi.AD579x.Base</p> uri + <p>Hostname or IP address of remote libIIO deviceHelp for adi.AD5790.Tx/uri is inherited from superclass matlabshared.libiio.base</p> Example Usage <pre><code>%% Configure device\ntx = adi.AD5790.Tx;\ntx.uri = \"ip:analog.local\";\ntx.DataSource = 'DMA';\ntx.EnableCyclicBuffers = true;\ntx.EnabledChannels = 1;\n\n%% Generate tone\namplitude = 2^15; frequency = 0.12e6;\nswv1 = dsp.SineWave(amplitude, frequency);\nswv1.SamplesPerFrame = 2^14;\n\nswv1.SampleRate = tx.SamplingRate;\ny = swv1();\n\n%% Send\ntx(y);\n</code></pre>"},{"location":"sysobjects/adi.AD5791.Tx/","title":"adi.AD5791.Tx","text":"adi.AD5791.Tx Transmits data to the AD5791 DAC    The adi.AD5791.Tx System object is a signal sink that can transmit    data to the AD5791.     tx = adi.AD5791.Tx;    tx = adi.AD5791.Tx('uri','ip:192.168.2.1'); AD5791 Datasheet Creation <p>The class can be instantiated in the following way with and without property name value pairs.</p> <pre><code>dev = adi.AD5791.Tx\ndev = adi.AD5791.Tx(Name, Value)\n</code></pre> Properties  Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them.  If a property is tunable, you can change its value at any time.  For more information on changing property values, see System Design in MATLAB Using System Objects. CodeSelect + <p>Set to 2s_complement/offset_binaryHelp for adi.AD5791.Tx/CodeSelect is inherited from superclass adi.AD579x.Base</p> DDSFrequencies + <p>Frequencies values in Hz of the DDS tone generators. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N &lt; this upper limit, other DDSs are not set.Help for adi.AD5791.Tx/DDSFrequencies is inherited from superclass adi.common.DDS</p> DDSPhases + <p>Phases of DDS tones in range [0,360000]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N &lt; this upper limit, other DDSs are not set.Help for adi.AD5791.Tx/DDSPhases is inherited from superclass adi.common.DDS</p> DDSScales + <p>Scale of DDS tones in range [0,1]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N &lt; this upper limit, other DDSs are not set.Help for adi.AD5791.Tx/DDSScales is inherited from superclass adi.common.DDS</p> DataSource + <p>Data source, specified as one of the following: 'DMA' \u2014 Specify the host as the source of the data. 'DDS' \u2014 Specify the DDS on the radio hardware as the source of the data. In this case, each channel has two additive tones.Help for adi.AD5791.Tx/DataSource is inherited from superclass adi.common.DDS</p> EnableCyclicBuffers + <p>Enable Cyclic Buffers, configures transmit buffers to be cyclic, which makes them continuously repeatHelp for adi.AD5791.Tx/EnableCyclicBuffers is inherited from superclass adi.common.DDS</p> EnabledChannels + <p>Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant</p> PowerDown + <p>Set to true/false to power-up/power-down the device channelsHelp for adi.AD5791.Tx/PowerDown is inherited from superclass adi.AD579x.Base</p> Raw + <p>Help for adi.AD5791.Tx/Raw is inherited from superclass adi.AD579x.Base</p> SampleRate + <p>Baseband sampling rate in Hz, specified as a scalar in samples per second. Help for adi.AD5791.Tx/SampleRate is inherited from superclass adi.AD579x.Base</p> SamplesPerFrame + <p>Number of samples per frame, specified as an even positive integer. Help for adi.AD5791.Tx/SamplesPerFrame is inherited from superclass adi.AD579x.Base</p> uri + <p>Hostname or IP address of remote libIIO deviceHelp for adi.AD5791.Tx/uri is inherited from superclass matlabshared.libiio.base</p> Example Usage <pre><code>%% Configure device\ntx = adi.AD5791.Tx;\ntx.uri = \"ip:analog.local\";\ntx.DataSource = 'DMA';\ntx.EnableCyclicBuffers = true;\ntx.EnabledChannels = 1;\n\n%% Generate tone\namplitude = 2^15; frequency = 0.12e6;\nswv1 = dsp.SineWave(amplitude, frequency);\nswv1.SamplesPerFrame = 2^14;\n\nswv1.SampleRate = tx.SamplingRate;\ny = swv1();\n\n%% Send\ntx(y);\n</code></pre>"},{"location":"sysobjects/adi.AD7124_4.Rx/","title":"adi.AD7124_4.Rx","text":"adi.AD7124-4.Rx Receives data from the AD7124 ADC    The adi.AD7124-4.Rx System object is a signal source that can receive    data from the AD7124-4.     rx = adi.AD7124_4.Rx;    rx = adi.AD7124_4.Rx('uri','ip:192.168.2.1'); AD7124-4 Datasheet Creation <p>The class can be instantiated in the following way with and without property name value pairs.</p> <pre><code>dev = adi.AD7124_4.Rx\ndev = adi.AD7124_4.Rx(Name, Value)\n</code></pre> Properties  Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them.  If a property is tunable, you can change its value at any time.  For more information on changing property values, see System Design in MATLAB Using System Objects. EnabledChannels + <p>Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant</p> SampleRate + <p>Baseband sampling rate in Hz, specified as a scalar in samples per second.Help for adi.AD7124_4.Rx/SampleRate is inherited from superclass adi.AD7124.Base</p> SamplesPerFrame + <p>Number of samples per frame, specified as an even positive integer.Help for adi.AD7124_4.Rx/SamplesPerFrame is inherited from superclass adi.AD7124.Base</p> dataTypeStr + <p>A String Representing the data typeHelp for adi.AD7124_4.Rx/dataTypeStr is inherited from superclass matlabshared.libiio.base</p> devName + <p>Name of the libIIO deviceHelp for adi.AD7124_4.Rx/devName is inherited from superclass matlabshared.libiio.base</p> kernelBuffersCount + <p>The number of buffers allocated in the kernel for data transfersHelp for adi.AD7124_4.Rx/kernelBuffersCount is inherited from superclass matlabshared.libiio.base</p> uri + <p>Hostname or IP address of remote libIIO deviceHelp for adi.AD7124_4.Rx/uri is inherited from superclass matlabshared.libiio.base</p> Example Usage <pre><code>%% Rx set up\nrx = adi.AD7124_4.Rx('uri','ip:analog.local');\nrx.SamplesPerFrame = 2^14;\nrx.EnabledChannels = 1;\n\n%% Run\nfor k=1:10\n    valid = false;\n    while ~valid\n        [out, valid] = rx();\n    end\nend\n\n%% Cleanup\nrelease(rx)\n</code></pre>"},{"location":"sysobjects/adi.AD7124_8.Rx/","title":"adi.AD7124_8.Rx","text":"adi.AD7124-8.Rx Receives data from the AD7124 ADC    The adi.AD7124-8.Rx System object is a signal source that can receive    data from the AD7124-8.     rx = adi.AD7124_8.Rx;    rx = adi.AD7124_8.Rx('uri','ip:192.168.2.1'); AD7124-8 Datasheet Creation <p>The class can be instantiated in the following way with and without property name value pairs.</p> <pre><code>dev = adi.AD7124_8.Rx\ndev = adi.AD7124_8.Rx(Name, Value)\n</code></pre> Properties  Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them.  If a property is tunable, you can change its value at any time.  For more information on changing property values, see System Design in MATLAB Using System Objects. EnabledChannels + <p>Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant</p> SampleRate + <p>Baseband sampling rate in Hz, specified as a scalar in samples per second.Help for adi.AD7124_8.Rx/SampleRate is inherited from superclass adi.AD7124.Base</p> SamplesPerFrame + <p>Number of samples per frame, specified as an even positive integer.Help for adi.AD7124_8.Rx/SamplesPerFrame is inherited from superclass adi.AD7124.Base</p> dataTypeStr + <p>A String Representing the data typeHelp for adi.AD7124_8.Rx/dataTypeStr is inherited from superclass matlabshared.libiio.base</p> devName + <p>Name of the libIIO deviceHelp for adi.AD7124_8.Rx/devName is inherited from superclass matlabshared.libiio.base</p> kernelBuffersCount + <p>The number of buffers allocated in the kernel for data transfersHelp for adi.AD7124_8.Rx/kernelBuffersCount is inherited from superclass matlabshared.libiio.base</p> uri + <p>Hostname or IP address of remote libIIO deviceHelp for adi.AD7124_8.Rx/uri is inherited from superclass matlabshared.libiio.base</p> Example Usage <pre><code>%% Rx set up\nrx = adi.AD7124_8.Rx('uri','ip:analog.local');\nrx.SamplesPerFrame = 2^14;\nrx.EnabledChannels = 1;\n\n%% Run\nfor k=1:10\n    valid = false;\n    while ~valid\n        [out, valid] = rx();\n    end\nend\n\n%% Cleanup\nrelease(rx)\n</code></pre>"},{"location":"sysobjects/adi.AD7380.Rx/","title":"adi.AD7380.Rx","text":"adi.AD7380.Rx Receives data from the AD7380 ADC    The adi.AD7380.Rx System object is a signal source that can receive    data from the AD7380.     rx = adi.AD7380.Rx;    rx = adi.AD7380.Rx('uri','192.168.2.1'); AD7380 Datasheet Creation <p>The class can be instantiated in the following way with and without property name value pairs.</p> <pre><code>dev = adi.AD7380.Rx\ndev = adi.AD7380.Rx(Name, Value)\n</code></pre> Properties  Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them.  If a property is tunable, you can change its value at any time.  For more information on changing property values, see System Design in MATLAB Using System Objects. EnabledChannels + <p>Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant</p> SampleRate + <p>Baseband sampling rate in Hz, specified as a scalar in samples per second. Options are: '256000','128000','64000','32000','16000','8000','4000', '2000','1000'</p> SamplesPerFrame + <p>Size of the frame in samplesHelp for adi.AD7380.Rx/SamplesPerFrame is inherited from superclass matlabshared.libiio.base</p> uri + <p>Hostname or IP address of remote libIIO deviceHelp for adi.AD7380.Rx/uri is inherited from superclass matlabshared.libiio.base</p> Example Usage <pre><code>%% Rx set up\nrx = adi.AD7380.Rx('uri','ip:analog.local');\nrx.SamplesPerFrame = 2^14;\nrx.EnabledChannels = 1;\n\n%% Run\nfor k=1:10\n    valid = false;\n    while ~valid\n        [out, valid] = rx();\n    end\nend\n\n%% Cleanup\nrelease(rx)\n</code></pre>"},{"location":"sysobjects/adi.AD7768.Rx/","title":"adi.AD7768.Rx","text":"adi.AD7768.Rx Receives data from the AD7768 ADC    The adi.AD7768.Rx System object is a signal source that can receive    data from the AD7768.     rx = adi.AD7768.Rx;    rx = adi.AD7768.Rx('uri','192.168.2.1'); AD7768 Datasheet Creation <p>The class can be instantiated in the following way with and without property name value pairs.</p> <pre><code>dev = adi.AD7768.Rx\ndev = adi.AD7768.Rx(Name, Value)\n</code></pre> Properties  Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them.  If a property is tunable, you can change its value at any time.  For more information on changing property values, see System Design in MATLAB Using System Objects. EnabledChannels + <p>Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant</p> SampleRate + <p>Baseband sampling rate in Hz, specified as a scalar in samples per second. Options are: '256000','128000','64000','32000','16000','8000','4000', '2000','1000'</p> SamplesPerFrame + <p>Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance.</p> uri + <p>Hostname or IP address of remote libIIO deviceHelp for adi.AD7768.Rx/uri is inherited from superclass matlabshared.libiio.base</p> Example Usage <pre><code>%% Rx set up\nrx = adi.AD7768.Rx('uri','ip:analog.local');\nrx.SamplesPerFrame = 2^14;\nrx.EnabledChannels = 1;\n\n%% Run\nfor k=1:10\n    valid = false;\n    while ~valid\n        [out, valid] = rx();\n    end\nend\n\n%% Cleanup\nrelease(rx)\n</code></pre>"},{"location":"sysobjects/adi.AD7768_1.Rx/","title":"adi.AD7768_1.Rx","text":"adi.AD7768_1.Rx Receives data from the AD7768-1 ADC    The adi.AD7768_1.Rx System object is a signal source that can receive    data from the AD7768-1.     rx = adi.AD7768_1.Rx;    rx = adi.AD7768_1.Rx('uri','192.168.2.1'); AD7768-1 Datasheet Creation <p>The class can be instantiated in the following way with and without property name value pairs.</p> <pre><code>dev = adi.AD7768_1.Rx\ndev = adi.AD7768_1.Rx(Name, Value)\n</code></pre> Properties  Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them.  If a property is tunable, you can change its value at any time.  For more information on changing property values, see System Design in MATLAB Using System Objects. CommonModeVolts + <p>Common mode voltage in volts, specified as a string Options are: '(AVDD1-AVSS)/2','2V5','2V05','1V9','1V65','1V1','0V9','OFF'</p> EnabledChannels + <p>Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant</p> SampleRate + <p>Baseband sampling rate in Hz, specified as a scalar in samples per second. Options are: '256000','128000','64000','32000','16000','8000','4000', '2000','1000'</p> SamplesPerFrame + <p>Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance.</p> uri + <p>Hostname or IP address of remote libIIO deviceHelp for adi.AD7768_1.Rx/uri is inherited from superclass matlabshared.libiio.base</p> Example Usage <pre><code>%% Rx set up\nrx = adi.AD7768_1.Rx('uri','ip:analog.local');\nrx.SamplesPerFrame = 2^14;\nrx.EnabledChannels = 1;\n\n%% Run\nfor k=1:10\n    valid = false;\n    while ~valid\n        [out, valid] = rx();\n    end\nend\n\n%% Cleanup\nrelease(rx)\n</code></pre>"},{"location":"sysobjects/adi.AD9081.Rx/","title":"adi.AD9081.Rx","text":"The adi.AD9081.Rx System object is a signal source that can receive    complex data from the AD9081.     rx = adi.AD9081.Rx;    rx = adi.AD9081.Rx('uri','ip:192.168.2.1'); AD9081 Datasheet Creation <p>The class can be instantiated in the following way with and without property name value pairs.</p> <pre><code>dev = adi.AD9081.Rx\ndev = adi.AD9081.Rx(Name, Value)\n</code></pre> Properties  Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them.  If a property is tunable, you can change its value at any time.  For more information on changing property values, see System Design in MATLAB Using System Objects. SamplingRate + <p>Baseband sampling rate in Hz, specified as a scalar in samples per second. This value is only readable once connected to hardware</p> ChannelNCOFrequencies + <p>Frequency of NCO in fine decimators in receive path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz, and N is the number of channels available.</p> MainNCOFrequencies + <p>Frequency of NCO in fine decimators in receive path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz, and N is the number of channels available.</p> ChannelNCOPhases + <p>Frequency of NCO in fine decimators in receive path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz, and N is the number of channels available.</p> MainNCOPhases + <p>Frequency of NCO in fine decimators in receive path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz, and N is the number of channels available.</p> TestMode + <p>Test mode of receive path. Options are: 'off' 'midscale_short' 'pos_fullscale' 'neg_fullscale' 'checkerboard' 'pn9' 'pn32' 'one_zero_toggle' 'user' 'pn7' 'pn15' 'pn31' 'ramp'</p> EnablePFIRs + <p>Enable use of PFIR/PFILT filters</p> PFIRFilenames + <p>Path(s) to FPIR/PFILT filter file(s). Input can be a string or cell array of strings. Files are loading in order</p> SamplesPerFrame + <p>Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance.Help for adi.AD9081.Rx/SamplesPerFrame is inherited from superclass ADI.AD9081.BASE</p> EnabledChannels + <p>Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant</p> uri + <p>Hostname or IP address of remote libIIO deviceHelp for adi.AD9081.Rx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE</p> Example Usage <pre><code>%% Rx set up\nrx = adi.adi.AD9081.Rx.Rx('uri','ip:analog.local');\nrx.CenterFrequency = 1e9;\nrx.EnabledChannels = 1;\n%% Run\nfor k=1:10\n    valid = false;\n    while ~valid\n        [out, valid] = rx();\n    end\nend\n</code></pre>"},{"location":"sysobjects/adi.AD9081.Tx/","title":"adi.AD9081.Tx","text":"The adi.AD9081.Tx System object is a signal sink that can tranmsit    complex data from the AD9081.     tx = adi.AD9081.Tx;    tx = adi.AD9081.Tx('uri','ip:ip:192.168.2.1'); AD9081 Datasheet Creation <p>The class can be instantiated in the following way with and without property name value pairs.</p> <pre><code>dev = adi.AD9081.Tx\ndev = adi.AD9081.Tx(Name, Value)\n</code></pre> Properties  Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them.  If a property is tunable, you can change its value at any time.  For more information on changing property values, see System Design in MATLAB Using System Objects. ChannelNCOFrequencies + <p>Frequency of NCO in fine decimators in transmit path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz.</p> MainNCOFrequencies + <p>Frequency of NCO in fine decimators in transmit path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz.</p> ChannelNCOPhases + <p>Frequency of NCO in fine decimators in transmit path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz.</p> MainNCOPhases + <p>Frequency of NCO in fine decimators in transmit path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz.</p> ChannelNCOGainScales + <p>Frequency of NCO in fine decimators in transmit path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz.</p> NCOEnables + <p>Vector of logicals which enabled individual NCOs in channel interpolators</p> SamplesPerFrame + <p>Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance.Help for adi.AD9081.Tx/SamplesPerFrame is inherited from superclass ADI.AD9081.BASE</p> EnabledChannels + <p>Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant</p> uri + <p>Hostname or IP address of remote libIIO deviceHelp for adi.AD9081.Tx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE</p> DataSource + <p>Data source, specified as one of the following: 'DMA' \u2014 Specify the host as the source of the data. 'DDS' \u2014 Specify the DDS on the radio hardware as the source of the data. In this case, each channel has two additive tones.Help for adi.AD9081.Tx/DataSource is inherited from superclass ADI.COMMON.DDS</p> DDSFrequencies + <p>Frequencies values in Hz of the DDS tone generators. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N &lt; this upper limit, other DDSs are not set.Help for adi.AD9081.Tx/DDSFrequencies is inherited from superclass ADI.COMMON.DDS</p> DDSScales + <p>Scale of DDS tones in range [0,1]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N &lt; this upper limit, other DDSs are not set.Help for adi.AD9081.Tx/DDSScales is inherited from superclass ADI.COMMON.DDS</p> DDSPhases + <p>Phases of DDS tones in range [0,360000]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N &lt; this upper limit, other DDSs are not set.Help for adi.AD9081.Tx/DDSPhases is inherited from superclass ADI.COMMON.DDS</p> EnableCyclicBuffers + <p>Enable Cyclic Buffers, configures transmit buffers to be cyclic, which makes them continuously repeatHelp for adi.AD9081.Tx/EnableCyclicBuffers is inherited from superclass ADI.COMMON.DDS</p> Example Usage <pre><code>%% Configure device\ntx = adi.adi.AD9081.Tx;\ntx.uri = \"ip:analog.local\";\ntx.CenterFrequency = 1e9;\ntx.DataSource = 'DMA';\ntx.EnableCyclicBuffers = true;\ntx.EnabledChannels = 1;\n%% Generate tone\namplitude = 2^15; frequency = 0.12e6;\nswv1 = dsp.SineWave(amplitude, frequency);\nswv1.ComplexOutput = true;\nswv1.SamplesPerFrame = 2^14;\nswv1.SampleRate = tx.SamplingRate;\ny = swv1();\n% Send\ntx(y);\n</code></pre>"},{"location":"sysobjects/adi.AD9467.Rx/","title":"adi.AD9467.Rx","text":"The adi.AD9467.Rx System object is a signal source that can receive    complex data from the AD9467.     rx = adi.AD9467.Rx;    rx = adi.AD9467.Rx('uri','ip:192.168.2.1'); AD9467 Datasheet Creation <p>The class can be instantiated in the following way with and without property name value pairs.</p> <pre><code>dev = adi.AD9467.Rx\ndev = adi.AD9467.Rx(Name, Value)\n</code></pre> Properties  Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them.  If a property is tunable, you can change its value at any time.  For more information on changing property values, see System Design in MATLAB Using System Objects. SamplingRate + <p>Baseband sampling rate in Hz, specified as a scalar in samples per second. This value read from the hardware after the object is setup.</p> TestMode + <p>Select ADC test mode. Options are: 'off' 'midscale_short' 'pos_fullscale' 'neg_fullscale' 'checkerboard' 'pn_long' 'pn_short' 'one_zero_toggle'</p> FilterHighPass3dbFrequency + <p>FilterHighPass3dbFrequency</p> Scale + <p>Scale received data. Possible options are: 0.030517 0.032043 0.033569 0.035095 0.036621 0.038146</p> SamplesPerFrame + <p>Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance.Help for adi.AD9467.Rx/SamplesPerFrame is inherited from superclass ADI.AD9467.BASE</p> EnabledChannels + <p>Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant</p> uri + <p>Hostname or IP address of remote libIIO deviceHelp for adi.AD9467.Rx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE</p> Example Usage <pre><code>%% Rx set up\nrx = adi.adi.AD9467.Rx.Rx('uri','ip:analog.local');\nrx.CenterFrequency = 1e9;\nrx.EnabledChannels = 1;\n%% Run\nfor k=1:10\n    valid = false;\n    while ~valid\n        [out, valid] = rx();\n    end\nend\n</code></pre>"},{"location":"sysobjects/adi.DAQ2.Rx/","title":"adi.DAQ2.Rx","text":"The adi.DAQ2.Rx System object is a signal source that can     receive complex data from the DAQ2.     rx = adi.DAQ2.Rx;    rx = adi.DAQ2.Rx('uri','ip:192.168.2.1'); User Guide Creation <p>The class can be instantiated in the following way with and without property name value pairs.</p> <pre><code>dev = adi.DAQ2.Rx\ndev = adi.DAQ2.Rx(Name, Value)\n</code></pre> Properties  Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them.  If a property is tunable, you can change its value at any time.  For more information on changing property values, see System Design in MATLAB Using System Objects. SamplingRate + <p>Baseband sampling rate in Hz, specified as a scalar in samples per second. This value is constantHelp for adi.DAQ2.Rx.SamplingRate is inherited from superclass ADI.AD9680.RX</p> EnabledChannels + <p>Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant</p> uri + <p>Hostname or IP address of remote libIIO deviceHelp for adi.DAQ2.Rx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE</p> SamplesPerFrame + <p>Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance.Help for adi.DAQ2.Rx/SamplesPerFrame is inherited from superclass ADI.AD9680.BASE</p> kernelBuffersCount + <p>The number of buffers allocated in the kernel for data transfersHelp for adi.DAQ2.Rx/kernelBuffersCount is inherited from superclass MATLABSHARED.LIBIIO.BASE</p> dataTypeStr + <p>A String Representing the data typeHelp for adi.DAQ2.Rx/dataTypeStr is inherited from superclass MATLABSHARED.LIBIIO.BASE</p> SamplesPerFrame + <p>Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance.Help for adi.DAQ2.Rx/SamplesPerFrame is inherited from superclass ADI.AD9680.BASE</p> Example Usage <pre><code>%% Rx set up\nrx = adi.adi.DAQ2.Rx.Rx('uri','ip:analog.local');\nrx.CenterFrequency = 1e9;\nrx.EnabledChannels = 1;\n%% Run\nfor k=1:10\n    valid = false;\n    while ~valid\n        [out, valid] = rx();\n    end\nend\n</code></pre>"},{"location":"sysobjects/adi.DAQ2.Tx/","title":"adi.DAQ2.Tx","text":"The adi.DAQ2.Tx System object is a signal source that can     send complex data to the DAQ2.     tx = adi.DAQ2.Tx;    tx = adi.DAQ2.Tx('uri','ip:192.168.2.1'); User Guide Creation <p>The class can be instantiated in the following way with and without property name value pairs.</p> <pre><code>dev = adi.DAQ2.Tx\ndev = adi.DAQ2.Tx(Name, Value)\n</code></pre> Properties  Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them.  If a property is tunable, you can change its value at any time.  For more information on changing property values, see System Design in MATLAB Using System Objects. SamplingRate + <p>Baseband sampling rate in Hz, specified as a scalar in samples per second. This value is constantHelp for adi.DAQ2.Tx.SamplingRate is inherited from superclass ADI.AD9144.TX</p> EnabledChannels + <p>Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant</p> uri + <p>Hostname or IP address of remote libIIO deviceHelp for adi.DAQ2.Tx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE</p> SamplesPerFrame + <p>Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance.Help for adi.DAQ2.Tx/SamplesPerFrame is inherited from superclass ADI.AD9144.BASE</p> kernelBuffersCount + <p>The number of buffers allocated in the kernel for data transfersHelp for adi.DAQ2.Tx/kernelBuffersCount is inherited from superclass MATLABSHARED.LIBIIO.BASE</p> dataTypeStr + <p>A String Representing the data typeHelp for adi.DAQ2.Tx/dataTypeStr is inherited from superclass MATLABSHARED.LIBIIO.BASE</p> DataSource + <p>Data source, specified as one of the following: 'DMA' \u2014 Specify the host as the source of the data. 'DDS' \u2014 Specify the DDS on the radio hardware as the source of the data. In this case, each channel has two additive tones.Help for adi.DAQ2.Tx/DataSource is inherited from superclass ADI.COMMON.DDS</p> DDSFrequencies + <p>Frequencies values in Hz of the DDS tone generators. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N &lt; this upper limit, other DDSs are not set.Help for adi.DAQ2.Tx/DDSFrequencies is inherited from superclass ADI.COMMON.DDS</p> DDSScales + <p>Scale of DDS tones in range [0,1]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N &lt; this upper limit, other DDSs are not set.Help for adi.DAQ2.Tx/DDSScales is inherited from superclass ADI.COMMON.DDS</p> DDSPhases + <p>Phases of DDS tones in range [0,360000]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N &lt; this upper limit, other DDSs are not set.Help for adi.DAQ2.Tx/DDSPhases is inherited from superclass ADI.COMMON.DDS</p> EnableCyclicBuffers + <p>Enable Cyclic Buffers, configures transmit buffers to be cyclic, which makes them continuously repeatHelp for adi.DAQ2.Tx/EnableCyclicBuffers is inherited from superclass ADI.COMMON.DDS</p> SamplesPerFrame + <p>Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance.Help for adi.DAQ2.Tx/SamplesPerFrame is inherited from superclass ADI.AD9144.BASE</p> Example Usage <pre><code>%% Configure device\ntx = adi.adi.DAQ2.Tx;\ntx.uri = \"ip:analog.local\";\ntx.CenterFrequency = 1e9;\ntx.DataSource = 'DMA';\ntx.EnableCyclicBuffers = true;\ntx.EnabledChannels = 1;\n%% Generate tone\namplitude = 2^15; frequency = 0.12e6;\nswv1 = dsp.SineWave(amplitude, frequency);\nswv1.ComplexOutput = true;\nswv1.SamplesPerFrame = 2^14;\nswv1.SampleRate = tx.SamplingRate;\ny = swv1();\n% Send\ntx(y);\n</code></pre>"},{"location":"sysobjects/output1/","title":"Output1","text":"adi.Pluto.Rx  Receive data from Analog Devices AD9361 transceiver  Description  The comm.SDRRxPluto System object\u2122 is a signal source that receives data from an Analog Devices\u00ae ADALM-PLUTO radio. This connection enables you to simulate and develop various software-defined radio applications.  The following diagram shows the interaction between MATLAB\u00ae, the comm.SDRRxPluto System object, and the radio hardware.   Creation <p>Syntax</p> Properties  Unless otherwise indicated, properties are nontunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them.  If a property is tunable, you can change its value at any time.  For more information on changing property values, see System Design in MATLAB Using System Objects."},{"location":"sysobjects/output1/#headingTwo","title":"CenterFrequency","text":"RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable.Help for adi.Pluto.Rx/CenterFrequency is inherited from superclass ADI.AD9361.RX"},{"location":"sysobjects/output1/#headingTwo","title":"SamplingRate","text":"Baseband sampling rate in Hz, specified as a scalar from 65105 to 61.44e6 samples per second.Help for adi.Pluto.Rx/SamplingRate is inherited from superclass ADI.AD9361.RX"},{"location":"sysobjects/output1/#headingTwo","title":"RFBandwidth","text":"RF Bandwidth of front-end analog filter in Hz, specified as a scalar from 200 kHz to 56 MHz.Help for adi.Pluto.Rx/RFBandwidth is inherited from superclass ADI.AD9361.RX"},{"location":"sysobjects/output1/#headingTwo","title":"GainControlModeChannel0","text":"specified as one of the following: 'slow_attack' \u2014 For signals with slowly changing power levels 'fast_attack' \u2014 For signals with rapidly changing power levels 'manual' \u2014 For setting the gain manually with the Gain property 'hybrid' \u2014 For configuring hybrid AGC modeHelp for adi.Pluto.Rx/GainControlModeChannel0 is inherited from superclass ADI.AD9361.RX"},{"location":"sysobjects/output1/#headingTwo","title":"GainChannel0","text":"Channel 0 gain, specified as a scalar from -3 dB to 71 dB. The acceptable minimum and maximum gain setting depends on the center frequency.Help for adi.Pluto.Rx/GainChannel0 is inherited from superclass ADI.AD9361.RX"},{"location":"sysobjects/output1/#headingTwo","title":"GainControlModeChannel1","text":"specified as one of the following: 'slow_attack' \u2014 For signals with slowly changing power levels 'fast_attack' \u2014 For signals with rapidly changing power levels 'manual' \u2014 For setting the gain manually with the Gain property 'hybrid' \u2014 For configuring hybrid AGC modeHelp for adi.Pluto.Rx/GainControlModeChannel1 is inherited from superclass ADI.AD9361.RX"},{"location":"sysobjects/output1/#headingTwo","title":"GainChannel1","text":"Channel 1 gain, specified as a scalar from -3 dB to 71 dB. The acceptable minimum and maximum gain setting depends on the center frequency.Help for adi.Pluto.Rx/GainChannel1 is inherited from superclass ADI.AD9361.RX"},{"location":"sysobjects/output1/#headingTwo","title":"LoopbackMode","text":"Option to set digital loopback mode, specified as 0, 1 or 2. Allows either to digitally loopback TX data into the RX path or vice versa. Value  | Mode ---------------------------  0 |  Disable  1 |  Digital TX -&gt; Digital RX  2 |  RF RX -&gt; RF TX Help for adi.Pluto.Rx/LoopbackMode is inherited from superclass ADI.AD9361.RX"},{"location":"sysobjects/output1/#headingTwo","title":"EnableQuadratureTracking","text":"Option to enable quadrature tracking, specified as true or false. When this property is true, IQ imbalance compensation is applied to the input signal.Help for adi.Pluto.Rx/EnableQuadratureTracking is inherited from superclass ADI.AD9361.RX"},{"location":"sysobjects/output1/#headingTwo","title":"EnableRFDCTracking","text":"Option to enable RF DC tracking, specified as true or false. When this property is true, an RF DC blocking filter is applied to the input signal.Help for adi.Pluto.Rx/EnableRFDCTracking is inherited from superclass ADI.AD9361.RX"},{"location":"sysobjects/output1/#headingTwo","title":"EnableBasebandDCTracking","text":"Option to enable baseband DC tracking, specified as true or false. When this property is true, a baseband DC blocking filter is applied to the input signal.Help for adi.Pluto.Rx/EnableBasebandDCTracking is inherited from superclass ADI.AD9361.RX"},{"location":"sysobjects/output1/#headingTwo","title":"RFPortSelect","text":"'A_BALANCED' 'B_BALANCED' 'C_BALANCED' 'A_N' 'A_P' 'B_N' 'B_P' 'C_N' 'C_P' 'TX_MONITOR1' 'TX_MONITOR2' 'TX_MONITOR1_2'Help for adi.Pluto.Rx/RFPortSelect is inherited from superclass ADI.AD9361.RX"},{"location":"sysobjects/output1/#headingTwo","title":"SamplesPerFrame","text":"Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance."},{"location":"sysobjects/output1/#headingTwo","title":"EnableCustomFilter","text":"Enable use of custom filter file to set SamplingRate, RFBandwidth, and FIR in datapaths"},{"location":"sysobjects/output1/#headingTwo","title":"CustomFilterFileName","text":"Path to custom filter file created from filter wizard"},{"location":"sysobjects/output1/#headingTwo","title":"EnabledChannels","text":"Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant"},{"location":"sysobjects/output1/#headingTwo","title":"uri","text":"Hostname or IP address of remote libIIO deviceHelp for adi.Pluto.Rx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE"},{"location":"sysobjects/output1/#headingTwo","title":"enIO","text":"If true, connects to libIIO device during simulationHelp for adi.Pluto.Rx/enIO is inherited from superclass MATLABSHARED.LIBIIO.BASE"}]}